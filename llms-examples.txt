# Defold Examples

This document contains Defold examples grouped by category.

## Animation

- [Animation State Machine](#examples:animation:animation_states) - This example demonstrates how to create a character animation system using a Finite State Machine (FSM) with smooth transitions between different character states
- [Cursor animation](#examples:animation:cursor) - This example shows how to set and animate the normalized cursor value
- [Easing functions (tweens)](#examples:animation:easing) - This example demonstrates different easing functions available in Defold
- [Euler Rotation](#examples:animation:euler_rotation) - This example shows how to animate the rotation of a game object using the euler game object property
- [Flipbook animation](#examples:animation:flipbook) - This example shows how to use a flipbook animation in a sprite
- [Spine animation](#examples:animation:spine) - This example shows Spine bone animation that blends when animation switches
- [Spinner animation](#examples:animation:spinner) - This example shows how a game object is rotated in discrete steps, matching the graphics of the progress spinner
- [Tween animation](#examples:animation:basic_tween) - This example shows how to tween animate the position of a game object
- [Tween animations chain](#examples:animation:chained_tween) - This example shows how to chain two tween animations of the position of a game object

## Basics

- [Message passing](#examples:basics:message_passing) - This example shows how to communicate between two script components in two separate game objects
- [Parent/child](#examples:basics:parent_child) - This example shows how to child a game object to a parent
- [Random numbers](#examples:basics:random_numbers) - This example shows how to generate pseudo-random numbers in Defold using built-in math API
- [Z-order](#examples:basics:z_order) - This example shows how to put sprites in front and behind of eachother

## Collection

- [Proxy](#examples:collection:proxy) - This example shows how to use collection proxies to load and unload collections
- [Splash](#examples:collection:splash) - This example shows how to use collection proxies to show a splash screen while loading a game menu
- [Time-step](#examples:collection:timestep) - This example shows how to speed up or slow down animations in a collection proxy by changing the time step of the collection proxy

## Debug

- [Physics debug](#examples:debug:physics) - This example allows you to toggle physics debug visualization as well as changing the time step so the simulation runs at one tenth of the speed
- [Visual profiler](#examples:debug:profile) - This example shows the on-screen profiler

## Factory

- [Dynamic factories](#examples:factory:dynamic) - This example shows how to change the prototype game object used by a factory component
- [Shoot bullets](#examples:factory:bullets) - This example shows how to dynamically spawn bullet game objects using a factory component
- [Spawn enemies with script properties](#examples:factory:spawn_properties) - This example shows how to spawn enemy game objects using a factory component with different properties
- [Spawn game object](#examples:factory:basic) - This example shows how to dynamically spawn game objects with a factory component

## File

- [Load JSON data](#examples:file:json_load) - This example shows how to load json data using sys
- [Save and Load](#examples:file:sys_save_load) - This example shows how to save and load data using sys

## Gui

- [Button](#examples:gui:button) - A GUI box node with an image texture and a script to make it act as a button
- [Drag](#examples:gui:drag) - This example shows how to drag a GUI box node
- [Get and set a gui font resource](#examples:gui:get_set_font) - This example shows how to get and set a font resource on a gui component
- [Get and set a gui material resource](#examples:gui:get_set_material) - This example shows how to get and set a material resource on a gui component
- [Get and set a gui texture resource](#examples:gui:get_set_texture) - This example shows how to get and set a texture resource on a gui component
- [GUI color](#examples:gui:color) - This example shows how change the color of GUI nodes at run-time
- [GUI progress indicators](#examples:gui:progress) - This example shows how to create various types of progress indicators
- [Health Bar](#examples:gui:healthbar) - This example demonstrates how to add different health bars
- [Layouts](#examples:gui:layouts) - This example demonstrates the use of layouts
- [Load texture](#examples:gui:load_texture) - This example shows how to load and set a dynamic texture on a gui box node
- [Pointer over](#examples:gui:pointer_over) - A GUI box node with an image texture and a script that react when pointer over this node
- [Slice-9](#examples:gui:slice9) - This example demonstrates slice-9 scaling gui box node
- [Stencil](#examples:gui:stencil) - A GUI box node with "Clipping mode" set to "STENCIL"

## Input

- [8 ways movement](#examples:input:move) - A very simple 8 ways movement setup with a single game object and a script that listens to input and updates the game object position accordingly
- [Down duration](#examples:input:down_duration) - Listens to input trigger "touch" and count mouse down duration in update method
- [Entity Picking](#examples:input:entity_picking) - This example demonstrates how to pick a game object from the 3D scene
- [Mouse and touch events](#examples:input:mouse_and_touch) - Shows how to read mouse/touch movement and mouse/touch button state
- [Text input](#examples:input:text) - Listens to text input trigger "type" and modifies the game object label with the alien's speech according to input

## Material

- [Custom Sprite](#examples:material:custom_sprite) - This example demonstrates a simple way to create and apply a custom sprite shader for changing colors and customizing an outline
- [Noise shader](#examples:material:noise) - This example shows how to use a noise function to generate clouds, smoke or similar effect using a shader
- [Repeating Background](#examples:material:repeating_background) - Create a scrolling background using a repeating texture on a model quad
- [Screenspace](#examples:material:screenspace) - This example shows how to create a custom material with two textures that blend together to create a pattern effect using screen space coordinates
- [Sprite local UV](#examples:material:sprite_local_uv) - This example shows how to get local UV coordinates of a sprite regardless of sprite size
- [Sprite Vertex Color Attribute](#examples:material:vertexcolor) - This example shows how to set and animate a vertex attribute
- [Unlit](#examples:material:unlit) - This example demonstrates how to create and apply an custom non-lit material to a 3D model
- [UV Gradient](#examples:material:uvgradient) - This example shows how to apply a basic shader to a full screen quad

## Mesh

- [Mesh](#examples:mesh:triangle) - This example shows how to create a basic mesh component in the shape of a triangle

## Model

- [AABB](#examples:model:aabb) - This example demonstrates how to use the `model
- [Character](#examples:model:character) - This example shows how to view and play skeletal animations on a glTF model
- [Cubemap Reflection](#examples:model:cubemap) - This example shows how to use a cubemap to draw environment reflections on a model
- [GLTF](#examples:model:gltf) - This example demonstrates how to use a glTF model
- [GPU Skinning](#examples:model:skinning) - This example demonstrates GPU skinning
- [Model Vertex Color](#examples:model:modelvertexcolor) - This example demonstrates how to apply a vertex color shader using exported attributes from a 3D model
- [Skybox](#examples:model:skybox) - This example shows how to create a skybox using a cubemap texture

## Movement

- [First-person 3D camera and movement](#examples:movement:3d_fps) - Control a first-person camera using WASD and mouse to look with cursor lock
- [Follow input](#examples:movement:follow) - This example shows how to make a game object continuously follow the mouse
- [Look at](#examples:movement:look_at) - This example shows how to rotate a game object to look at the mouse cursor
- [Look rotation](#examples:movement:look_rotation) - This example shows how to rotate a game object to look at the object in 3D space
- [Move forward](#examples:movement:move_forward) - This example shows how to move a game object in the direction it is rotated/facing
- [Move to target](#examples:movement:move_to) - This example shows how to make a game object move to the position the user clicks
- [Movement speed](#examples:movement:movement_speed) - This example shows how to move a game object with accelerating speed
- [Moving game object](#examples:movement:simple_move) - This example shows how to move a game object

## Particles

- [Modifiers](#examples:particles:modifiers) - This example shows particle effect modifiers
- [Particle effect](#examples:particles:particlefx) - This example shows a simple particle effect
- [Particle Effect Emission Space](#examples:particles:particlefx_emission_space) - This example demonstrates the difference between local and world particle emission spaces
- [Particle effect example - confetti](#examples:particles:confetti) - This example shows a simple particle effect to imitate confetti
- [Particle effect example - fire and smoke](#examples:particles:fire_and_smoke) - This example shows a simple particle effect for imitating fire and smoke
- [Particle effect example - fireworks](#examples:particles:fireworks) - This example shows a fireworks effect made with particles

## Physics

- [Dynamic physics](#examples:physics:dynamic) - This example shows a simple setup with dynamic physics objects
- [Hinge joint physics](#examples:physics:hinge_joint) - This example shows a simple setup with a dynamic body physics object and two dynamic wheel physics object joined together with a joint of type "hinge"
- [Kinematic physics](#examples:physics:kinematic) - This example shows a simple setup with a kinematic physics objects
- [Knockback](#examples:physics:knockback) - This example shows how to create a knockback effect when hit
- [Pendulum physics](#examples:physics:pendulum) - This example shows a simple setup with a static pivot and two dynamic weights - physics objects joined together with a joint of type "fixed" and "spring"
- [Raycast](#examples:physics:raycast) - This example shows how to use physics raycasts to detect collisions along a straight line from a start point to an end point
- [Trigger](#examples:physics:trigger) - This example shows how a physics trigger is used to trigger an event

## Render

- [Camera](#examples:render:camera) - This example shows how to use a camera component and have it follow a game object
- [Orbit Camera](#examples:render:orbit_camera) - This example demonstrates how to create script to control a 3D camera with the mouse
- [Post-processing](#examples:render:post_processing) - This example shows how to apply a post-processing effect by drawing to a render target and then to a fullscreen quad using a post processing shader
- [Screen to World](#examples:render:screen_to_world) - This example shows how to convert from screen to world coordinates while using a camera
- [World to Screen](#examples:render:world_to_screen) - This example demonstrates how to convert 3D world coordinates to 2D screen coordinates using camera transformations

## Resource

- [Create atlas](#examples:resource:create_atlas) - This example shows how to create an atlas with two images and use it on a sprite and in a gui
- [Modify atlas](#examples:resource:modify_atlas) - This example shows how to replace an image in an atlas

## Sound

- [Fade In-Out](#examples:sound:fade_in_out) - This example shows how to make Fade-In and fade Fade-Out music
- [Get and set sound](#examples:sound:get_set_sound) - This example shows how to change which sound a sound component plays
- [Music](#examples:sound:music) - This example shows how to play a piece of music, stored as an
- [Panning](#examples:sound:panning) - This example demonstrates how to pan a sound effect according to a GO's(game object) position on the screen

## Sprite

- [Bunnymark](#examples:sprite:bunnymark) - This is a performance test for sprites
- [Change sprite image](#examples:sprite:changeimage) - This example shows how to change the image of a sprite
- [Flip](#examples:sprite:flip) - This example demonstrates flipping a sprite animation vertically and horizontally
- [Multiple Sprite Samplers](#examples:sprite:samplers) - This example shows how to sample from more than one image when drawing a sprite
- [Sprite cursor](#examples:sprite:cursor) - This example shows how to use the sprite animation cursor and frame count to manually select a specific frame
- [Sprite size](#examples:sprite:size) - This example shows how to get the size of a sprite at run-time
- [Sprite tint](#examples:sprite:tint) - This example shows how tint a sprite at run-time

## Tilemap

- [Get and set tiles](#examples:tilemap:get_set_tile) - This example shows how to get and set tiles of a tilemap
- [Tilemap collisions](#examples:tilemap:collisions) - This example shows how to detect collisions on tilemaps

## Timer

- [Cancel timer example](#examples:timer:cancel_timer) - This example shows how to create timer and cancel it anytime, using built-in timer API
- [Repeating timer example](#examples:timer:repeating_timer) - This example shows how to create timer that repeats endlessly every second
- [Trigger timer example](#examples:timer:trigger_timer) - This example shows how to create timer that triggers counting every 1s and can be triggered manually and asynchronously as a reaction to user input

<!-- animation/animation_states -->

# Animation State Machine {#examples:animation:animation_states}

This example demonstrates how to create a character animation system using a Finite State Machine (FSM) with smooth transitions between different character states.

[Project files](https://github.com/defold/examples/tree/master/animation/animation_states)

# A simple Finite State Machine for animations.

This example shows how to create a responsive character animation system using a **Finite State Machine (FSM)**. The character can smoothly transition between different states like idle, running, jumping, attacking, and crouching based on player input. This is a fundamental technique used in most 2D platformers and action games.

## What You'll Learn?

- How to implement a state machine for character animations
- How to handle complex input combinations and priorities## Key Concepts

**State Machine**: A design pattern where an object can be in only one state at a time, with clear rules for transitioning between states.

**Input Priority**: A system that determines which actions take precedence when multiple keys are pressed simultaneously.

**Animation Transitions**: Smooth changes between different animations, often with intermediate "transition" animations.## Key Concepts

**State Machine**: A design pattern where an object can be in only one state at a time, with clear rules for transitioning between states.

**Input Priority**: A system that determines which actions take precedence when multiple keys are pressed simultaneously.

**Animation Transitions**: Smooth changes between different animations, often with intermediate "transition" animations.
- How to create smooth transitions between animation states
- How to make sprites flip direction based on movement
- How to add visual effects (like jump animations)
- How to communicate between game objects using messages

## Setup

The example consists of two main game objects:

knight
: The animated character. Contains:
  - A *Sprite* component with the knight character image and animations.
  - A *Script* component (`knight.script`) that implements the state machine logic, handles input, and manages animation transitions.

gui
: The user interface. Contains:
  - A *GUI* component (`control.gui`) that has 6 nodes displaying states and text description for the example.
  - A *GUI Script* component (`control.gui_script`) that receives messages from the knight and updates the visual state indicators.

> **Note:**
> The GUI in this example is not required for understanding the state machine logic, it only visually shows the active animation state. You can view the GUI source in the project files on Github still though.

## Animation Atlas

The sprite component uses a flipbook animation that is set up in an atlas:

> For this example we used the Free Knight Character by Nauris 'aamatniekss' available here: https://aamatniekss.itch.io/fantasy-knight-free-pixelart-animated-character

The atlas contains multiple animations for different character states:
- **idle**: Standing still animation
- **run**: Running animation (looped)
- **jump**: Jumping animation (plays once)
- **attack**: Attacking animation (plays once)
- **turn_around**: Turning animation (plays once)
- **crouch_idle**: Crouching idle anim **Note:** ation
- **crouch_walk**: Crouch walking animation
- **crouch_attack**: Crouch attacking animation
- **to_crouch**: Transition from standing to crouching
- **from_crouch**: Transition from crouching to standing

## Input Bindings

| Key             | Action                         |
|-----------------|--------------------------------|
| **Left Arrow / Right Arrow** | Move left/right   |
| **Space**       | Jump                           |
| **X**           | Attack                         |
| **C**           | Crouch (hold to stay crouched) |

## How It Works?

The character uses a **finite state machine** - a programming pattern where the character can only be in one "state" at a time. Each state can define certain things like:
- Which animation to play
- Whether the animation loops or plays once
- What happens when different keys are pressed
- What state to go to when the animation finishes

The system processes input with **priorities**: Attack > Jump > Movement > Crouch/Stand > Turning. This ensures that important actions (like attacking) can interrupt less important ones (like walking).

## Key Concepts

**State Machine**: A design pattern where an object can be in only one state at a time, with clear rules for transitioning between states.

**Input Priority**: A system that determines which actions take precedence when multiple keys are pressed simultaneously.

**Animation Transitions**: Smooth changes between different animations, often with intermediate "transition" animations.

## Scripts

### knight.script

```lua
-- ============================================================================
-- KNIGHT ANIMATION STATE MACHINE - Beginner Friendly Example
-- ============================================================================
-- This script demonstrates how to create a character animation system using
-- a simple implementation of a Finite State Machine (FSM) in Defold.

-- Input action hashes - these connect keyboard/gamepad buttons to our code
-- In Defold, we use hash() to convert strings to efficient identifiers
local INPUT = {
	JUMP = hash("jump"),
	CROUCH = hash("crouch"),
	ATTACK = hash("attack"),
	LEFT = hash("left"),
	RIGHT = hash("right")
}

-- ============================================================================
-- STATE MACHINE CONFIGURATION
-- ============================================================================
-- This table defines ALL possible states our character can be in.
-- Think of it as a "rule book" that tells the game:
-- - What animation to play in each state
-- - Whether the animation should loop or play once
-- - What should happen when the player presses different buttons
--
-- Each state is like a "mode" the character is in. For example:
-- - "standing_idle" = character is standing still, playing idle animation, looped
--
-- The "on_" properties define what happens when inputs are pressed, e.g.:
-- - on_attack = what state to go to when attack button is pressed
-- - on_move = what state to go to when movement keys are pressed
-- - default_next = what state to go to when animation finishes (for non-looped animations)

local STATE_CONFIG = {
	-- STANDING STATES - Character is upright and can move freely
	-- These are the "normal" states when the character is standing
	standing_idle = {
		animation = "idle",      -- Play the "idle" animation from the sprite atlas
		is_looped = true,        -- Keep playing this animation over and over
		on_crouch = "to_crouch", -- If crouch key pressed, go to "to_crouch" state
		on_attack = "standing_attack", -- If attack key pressed, go to "standing_attack" state
		on_jump = "standing_jump", -- If jump key pressed, go to "standing_jump" state
		on_move = "standing_run", -- If movement keys pressed, go to "standing_run" state
		on_turn = "standing_turn" -- If character turns around, go to "standing_turn" state
	},
	standing_run = {
		animation = "run",       -- Play the running animation
		is_looped = true,        -- Loop the running animation continuously
		on_crouch = "to_crouch", -- Can still crouch while running
		on_attack = "standing_attack", -- Can attack while running
		on_jump = "standing_jump", -- Can jump while running
		on_stop = "standing_idle", -- When movement stops, go back to idle
		on_turn = "standing_turn" -- When turning around, play turn animation
	},
	standing_jump = {
		animation = "jump",      -- Play the jump animation
		is_looped = false,       -- Play jump animation only once
		default_next = "standing_idle" -- When jump animation finishes, go back to idle
	},
	standing_attack = {
		animation = "attack",    -- Play the attack animation
		is_looped = false,       -- Play attack animation only once
		default_next = "standing_idle" -- When attack finishes, go back to idle
	},
	standing_turn = {
		animation = "turn_around", -- Play the turn around animation
		is_looped = false,        -- Play turn animation only once
		default_next = "standing_idle", -- When turn finishes, go to idle
		on_turn = "standing_turn" -- If turning again while already turning, keep turning
	},

	-- CROUCHING STATES - Character is in low position, limited movement
	-- When crouching, the character can't jump but can still move and attack
	crouching_idle = {
		animation = "crouch_idle", -- Play the crouching idle animation
		is_looped = true,         -- Loop the crouch idle animation
		on_stand = "to_standing", -- If crouch key released, start standing up
		on_attack = "crouching_attack", -- Can attack while crouching
		on_move = "crouching_run" -- Can move while crouching (crouch walk)
	},
	crouching_run = {
		animation = "crouch_walk", -- Play the crouch walking animation
		is_looped = true,         -- Loop the crouch walk animation
		on_stand = "to_standing", -- Can stand up while crouch walking
		on_attack = "crouching_attack", -- Can attack while crouch walking
		on_stop = "crouching_idle" -- When movement stops, go to crouch idle
	},
	crouching_attack = {
		animation = "crouch_attack", -- Play the crouch attack animation
		is_looped = false,         -- Play attack animation only once
		default_next = "crouching_idle", -- When attack finishes, go to crouch idle
		on_stand = "to_standing",  -- Can stand up even while attacking
	},

	-- TRANSITION STATES - Intermediate animations between major state changes
	-- These states handle the smooth transition between standing and crouching
	to_crouch = {
		animation = "to_crouch",  -- Play the "going into crouch" animation
		is_looped = false,        -- Play transition animation only once
		default_next = "crouching_idle" -- When transition finishes, go to crouch idle
	},
	to_standing = {
		animation = "from_crouch", -- Play the "standing up from crouch" animation
		is_looped = false,       -- Play transition animation only once
		default_next = "standing_idle" -- When transition finishes, go to standing idle
	}
}

-- ============================================================================
-- MOVEMENT AND DIRECTION LOGIC
-- ============================================================================

--- Updates movement state and sprite direction based on input
--- This function figures out:
--- 1. Is the character moving? (left or right key pressed)
--- 2. Which direction is the character facing? (left or right)
--- 3. Did the character just turn around? (for turn animation)
--- @param self table Script instance with input flags
local function update_movement_state(self)
	-- Start by assuming the character is not moving
	self.is_moving = false

	-- Remember the previous facing direction to detect turns
	local previous_is_flipped = self.is_flipped

	-- Check movement input and update facing direction
	if self[INPUT.LEFT] and not self[INPUT.RIGHT] then
		-- Left key is pressed and right key is not pressed
		self.is_moving = true
		self.is_flipped = true -- Character faces left (sprite is flipped)
	elseif self[INPUT.RIGHT] and not self[INPUT.LEFT] then
		-- Right key is pressed and left key is not pressed
		self.is_moving = true
		self.is_flipped = false -- Character faces right (sprite is not flipped)
	end
	-- If both keys are pressed or neither is pressed, character doesn't move

	-- Detect if the character just turned around - used to trigger the "turn around" animation
	self.is_turning = self.is_flipped ~= previous_is_flipped
end


-- ============================================================================
-- STATE TRANSITION LOGIC
-- ============================================================================

--- Determines the next state based on current input and state configuration
--- This is the "brain" of our state machine - it decides what state to go to next
---
--- INPUT PRIORITY SYSTEM (in order of importance):
--- 1. Attack - Highest priority, can interrupt most other actions
--- 2. Jump - High priority, can interrupt movement
--- 3. Movement - Medium priority, handles start/stop moving
--- 4. Crouch/Stand - Medium priority, changes posture
--- 5. Turn - Lowest priority, only when changing direction
---
--- @param self table Script instance with input flags and current state
--- @return string|nil Next state name or nil if no transition needed
local function get_next_state(self)
	-- Get current input state and configuration
	local is_crouching = self[INPUT.CROUCH] -- Is crouch key currently pressed?
	local config = STATE_CONFIG[self.state] -- Get rules for current state
	local next_state = nil               -- Will hold the next state to go to

	-- PRIORITY 1: ATTACK INPUT (Highest Priority)
	-- Attack can interrupt almost any other action
	if self[INPUT.ATTACK] then
		next_state = config.on_attack -- Go to attack state if current state allows it
	end

	-- PRIORITY 2: JUMP INPUT (High Priority)
	-- Jump can interrupt movement but not attack
	if self[INPUT.JUMP] then
		next_state = config.on_jump -- Go to jump state if current state allows it
	end

	-- PRIORITY 3: MOVEMENT STATE CHANGES (Medium Priority)
	-- Handle starting to move or stopping movement
	if self.is_moving and config.on_move then
		next_state = config.on_move -- Character is moving and current state has a "move" transition
	elseif not self.is_moving and config.on_stop then
		next_state = config.on_stop -- Character stopped moving and current state has a "stop" transition
	end

	-- PRIORITY 4: CROUCH/STAND STATE CHANGES (Medium Priority)
	-- Handle posture changes (standing vs crouching)
	if is_crouching and config.on_crouch then
		next_state = config.on_crouch -- Crouch key is pressed and current state allows crouching
	elseif not is_crouching and config.on_stand then
		next_state = config.on_stand -- Crouch key is released and current state allows standing
	end

	-- PRIORITY 5: DIRECTION CHANGE (Lowest Priority)
	-- Handle turning around (only when changing direction)
	if self.is_turning and config.on_turn then
		next_state = config.on_turn -- Character just turned around and current state has turn animation
	end

	-- Return the next state (or nil if no transition is needed)
	return next_state
end

-- ============================================================================
-- VISUAL LAYER - Handles all visual effects and animations
-- ============================================================================

--- Updates all visual elements based on current character state
--- This function is responsible for making the character look correct on screen:
--- - Playing the right animation for the current state
--- - Flipping the sprite to face the right direction
--- - Creating special effects (like the jump animation)
--- - Updating the GUI to show current state
--- @param self table Script instance with current state and flip information
local function update_visuals(self)
	-- Get the configuration for the current state
	local config = STATE_CONFIG[self.state]

	-- Play the animation for the current state
	sprite.play_flipbook("#sprite", config.animation)

	-- Visualize the jump effect
	-- (When jumping, we add a visual effect by moving the character up and down)
	if self.state == "standing_jump" then
		local pos = go.get_position()
		-- Animate the Y position to simulate a jump visually
		go.animate(".", "position.y", go.PLAYBACK_ONCE_PINGPONG, pos.y + 50, go.EASING_INOUTCUBIC, 0.6)
	else
		-- If not jumping, make sure any jump animation is cancelled and reset the character to ground level
		go.cancel_animations(".", "position.y")
		local pos = go.get_position()
		go.set_position(vmath.vector3(pos.x, 600, pos.z)) -- 600 is our ground level Y position
	end

	-- Update the GUI - send a message to the GUI component to update the UI
	msg.post("gui", "animation_state_changed", {
		state = self.state
	})
end

-- ============================================================================
-- DEFOLD LIFECYCLE FUNCTIONS
-- ============================================================================

--- Initializes the knight character when the game starts
--- It sets up the initial state and prepares the character for input
--- @param self table Script instance - this is automatically provided by Defold
function init(self)
	-- Set up initial state machine state as "standing_idle"
	self.state = "standing_idle"

	-- Set up movement and direction flags
	self.is_flipped = false -- Character starts facing right (not flipped)
	self.is_moving = false -- Character starts not moving
	self.is_turning = false -- Character starts not turning

	-- Initialize all input flags - start with all keys "not pressed" (false)
	self[INPUT.LEFT] = false -- Left arrow key
	self[INPUT.RIGHT] = false -- Right arrow key
	self[INPUT.JUMP] = false -- Space bar
	self[INPUT.ATTACK] = false -- Attack button (X)
	self[INPUT.CROUCH] = false -- Crouch button (C)

	-- Display the initial state visually
	update_visuals(self)

	-- Enable input handling
	msg.post(".", "acquire_input_focus")
end

--- Handles input events from keyboard every time the player presses or releases a key
--- It updates our input tracking and triggers state transitions
--- @param self table Script instance
--- @param action_id hash Which input was pressed (like "jump", "attack", etc.)
--- @param action table Contains information about the input (pressed/released)
function on_input(self, action_id, action)
	-- Update input state - keep track of which keys are currently being pressed:
	if action.pressed then
		self[action_id] = true -- Key was just pressed down
	elseif action.released then
		self[action_id] = false -- Key was just released
	end

	-- Process state machine:
	update_movement_state(self)          -- Update movement and direction state based on input
	local next_state = get_next_state(self) -- Decide what state to go to next

	-- If we determined a new state is needed, switch to it and update visuals:
	if next_state then
		self.state = next_state -- Change to the new state
		update_visuals(self) -- Update the visual appearance
	end
end

--- Handles messages from other game objects
--- We use it to handle messages that comes to the script when animations finish playing
--- @param self table Script instance
--- @param message_id hash What type of message this is
function on_message(self, message_id, message)
	-- This message is sent when a non-looped animation finishes playing (like attack, jump, or turn animations)
	if message_id == hash("animation_done") then

		-- Flip the sprite horizontally when the character just finished turning
		if message.id == hash("turn_around") then
			sprite.set_hflip("#sprite", self.is_flipped)
		end

		-- Process state machine:
		update_movement_state(self)       -- Update movement and direction state based on input
		local next_state = get_next_state(self) -- Decide what state to go to next

		-- Switch to the next state (or default next) and update visuals
		self.state = next_state or STATE_CONFIG[self.state].default_next
		update_visuals(self)
	end
end
```

<!-- animation/cursor -->

# Cursor animation {#examples:animation:cursor}

This example shows how to set and animate the normalized cursor value.

[Project files](https://github.com/defold/examples/tree/master/animation/cursor)

The example uses one game object with a sprite component and a label (to show the duration). The game object contains the script that sets and animates the normalized cursor value making the sprite's animation progress and shows the duration value on the label:

## Scripts

### cursor.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	-- Get the current value on component "sprite"
	self.duration = 0 -- <2>
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_button_left") and action.pressed then -- <3>
		self.duration = self.duration + 1 -- <4>
		if self.duration > 3 then  -- <5>
			self.duration = 0
		end
		label.set_text("#info", "Cursor animation duration: "..self.duration)  -- <6>
		go.cancel_animations("#sprite", "cursor")  -- <7>
		go.set("#sprite", "cursor", 0.0)  -- <8>
		go.animate("#sprite", "cursor", go.PLAYBACK_LOOP_FORWARD, 1, go.EASING_LINEAR, self.duration) -- <9>
	end
end

--[[
1. Tell the engine that this object ("." is shorthand for the current game object) should listen to input. Any input will be received in the `on_input()` function.
2. Store a duration time used in this example (for defining how long the cursor animation should take) in self reference.
3. If we receive input (touch or mouse click) we change the duration of the cursor animation.
4. Increase the duration.
5. If the duration is larger than 3, set it back to 0 to make a circular change of the duration.
6. Set the text of the label with id `info` to show the current duration of the animation to user.
7. Cancel previous animation on cursor value.
8. Reset cursor value to 0.
9. Start new animation of cursor value with playback set to be looped and in foward direction (increasing cursor value), linear easing and new duration.
--]]
```

<!-- animation/easing -->

# Easing functions (tweens) {#examples:animation:easing}

This example demonstrates different easing functions available in Defold.

[Project files](https://github.com/defold/examples/tree/master/animation/easing)

This example demonstrates different easing functions available in Defold.

Read more about property animations in the [manual](https://defold.com/manuals/property-animation/).

<!-- animation/euler_rotation -->

# Euler Rotation {#examples:animation:euler_rotation}

This example shows how to animate the rotation of a game object using the euler game object property.

[Project files](https://github.com/defold/examples/tree/master/animation/euler_rotation)

## Scripts

### euler_rotation.script

```lua
function init(self)
	-- rotate clockwise one full revolution in two seconds
	go.animate(".", "euler.z", go.PLAYBACK_LOOP_FORWARD, -360, go.EASING_LINEAR, 2)
end
```

<!-- animation/flipbook -->

# Flipbook animation {#examples:animation:flipbook}

This example shows how to use a flipbook animation in a sprite

[Project files](https://github.com/defold/examples/tree/master/animation/flipbook)

The sprite component in the game object uses a flipbook animation that is set up in an atlas:

<!-- animation/spine -->

# Spine animation {#examples:animation:spine}

This example shows Spine bone animation that blends when animation switches.

[Project files](https://github.com/defold/examples/tree/master/animation/spine)

## Scripts

### spine.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.state = "idle" -- <2>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		local properties = { blend_duration = 0.3 } -- <3>
		if self.state == "idle" then -- <4>
			spine.play_anim("#spinemodel", hash("run"), go.PLAYBACK_LOOP_FORWARD, properties)
			label.set_text("#label", "Click to idle...")
			self.state = "run"
		elseif self.state == "run" then -- <5>
			spine.play_anim("#spinemodel", hash("idle"), go.PLAYBACK_LOOP_FORWARD, properties)	
			label.set_text("#label", "Click to run...")
			self.state = "idle"
		end			
	end	
end

--[[
1. Tell the engine that this game object (".", which is shorthand for the current game object) should receive input.
2. Store state for this instance. Use a string that will be either "idle" or "run", reflecting the animation.
3. If user clicks, set up animation properties. Blend duration larger that 0 to get smoother transition between animations.
4. If state is currently "idle", play "run" animation, change text on label and change the state variable to "run".
5. If state is currently "run", play "idle" animation, change text on label and change the state variable to "idle".
--]]
```

<!-- animation/spinner -->

# Spinner animation {#examples:animation:spinner}

This example shows how a game object is rotated in discrete steps, matching the graphics of the progress spinner.

[Project files](https://github.com/defold/examples/tree/master/animation/spinner)

## Scripts

### spinner.script

```lua
function init(self)
	self.t = 0 -- <1>
	self.speed = 16 -- <2>
end

function update(self, dt)
	self.t = self.t + dt -- <3>
	local step = math.floor(self.t * self.speed) -- <4>
	local angle = math.pi / 6 * step -- <5>
	local rot = vmath.quat_rotation_z(-angle) -- <6>
	go.set_rotation(rot) -- <7>
end

--[[
1. Store a timer value (seconds elapsed) in the current script component (accessed through `self`).
2. A speed value. How many rotation steps to perform each second.
3. Increase timer value with the delta time elapsed since last `update()`.
4. Calculate which step to rotate to.
5. Calculate rotation angle (in radians) based on which step to rotate to.
6. Create a rotation quaternion with `angle` rotation around the Z axis.
7. Set the rotation on the current game object.
--]]
```

<!-- animation/basic_tween -->

# Tween animation {#examples:animation:basic_tween}

This example shows how to tween animate the position of a game object.

[Project files](https://github.com/defold/examples/tree/master/animation/basic_tween)

## Scripts

### spaceship.script

```lua
function init(self)
    local to = vmath.vector3(400, 400, 0) -- <1>
    go.animate(".", "position", go.PLAYBACK_LOOP_PINGPONG, to, go.EASING_INOUTSINE, 2) -- <2>
end

--[[
1. The destination to move the game object to (x, y, z)
2. This function animates the game object position to the destination and back again repeatedly over a period of 2 seconds. The movement uses a sine-wave easing curve to slow down at the end points.
--]]
```

<!-- animation/chained_tween -->

# Tween animations chain {#examples:animation:chained_tween}

This example shows how to chain two tween animations of the position of a game object. In addition, the scale and tint is animated separately.

[Project files](https://github.com/defold/examples/tree/master/animation/chained_tween)

## Scripts

### spaceship.script

```lua
local up_down -- <1>
local left_right

function up_down(self) -- <2>
    go.animate(".", "position.y", go.PLAYBACK_ONCE_PINGPONG, 624, go.EASING_INOUTSINE, 2, 0, left_right)
end

function left_right(self) -- <3>
    go.animate(".", "position.x", go.PLAYBACK_ONCE_PINGPONG, 660, go.EASING_INOUTSINE, 2, 0, up_down)	
end

function init(self)
    up_down(self) -- <4>
    go.animate(".", "scale.y", go.PLAYBACK_LOOP_PINGPONG, 0.5, go.EASING_INOUTSINE, 1) -- <5>
    go.animate("#sprite", "tint.x", go.PLAYBACK_LOOP_PINGPONG, 0.0, go.EASING_INOUTSINE, 1.5) -- <6>
end

--[[
1. In Lua, local variables must be declared prior to their use.
   Since the functions `up_down()` and `left_right()` refer to 
   each other we "forward declare" the names `up_down` and 
   `left_right` before the function definitions.
2. This function animates the game object position's y component,
   then calls the function `left_right()` on completion.
3. This function animates the game object position's x component,
   then calls the function `up_down()` on completion.
4. Start by calling the `up_down()` function.
5. In parallel, tween the scale y component.
6. And the sprite's tint x component (which is the red value).
--]]
```

<!-- basics/message_passing -->

# Message passing {#examples:basics:message_passing}

This example shows how to communicate between two script components in two separate game objects.

[Project files](https://github.com/defold/examples/tree/master/basics/message_passing)

## Scripts

### spaceship1.script

```lua
local function landed(self) -- <2>
	label.set_text("#speech", "I'm there!")
	msg.post("spaceship2#script", "i'm there")
end

function on_message(self, message_id, message, sender)
	if message_id == hash("go to") then -- <1>
		label.set_text("#speech", "Ok...")
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, message.position, go.EASING_INOUTCUBIC, 1, 0, landed)
	end	
end

--[[
1. If someone sends us a "go to" message, set the speech label text and animate to the position supplied
   in the message data. At the end of animation, call the function `landed()`
2. This function is called when the position animation is completed. It sets the speech label text and then
   sends a message called "i'm there" to the component "script" in the "spaceship2" game object.
--]]
```

### spaceship2.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.moving = false -- <2>
end

local function landed(self) -- <6>
	self.moving = false
	label.set_text("#speech", "Hey, go to the opposite side!")
	local pos = go.get_position()
	local opposite = vmath.vector3()
	opposite.x = 720 - pos.x
	opposite.y = 720 - pos.y
	msg.post("spaceship1#script", "go to", { position = opposite })
end

function on_message(self, message_id, message, sender)
	if message_id == hash("go to") then -- <5>
		self.moving = true
		label.set_text("#speech", "I'm going...")
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, message.position, go.EASING_INOUTCUBIC, 1.5, 0, landed)
	elseif message_id == hash("i'm there") then -- <7>
		label.set_text("#speech", "Great!")		
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed and not self.moving then -- <3>
		local pos = vmath.vector3(action.x, action.y, 0)
		msg.post("#", "go to", { position = pos }) -- <4>
	end
end

--[[
1. Tell the engine that we want to receive input.
2. Store a flag in the current script component instance that tells us if the spaceship is moving or not.
3. If user clicked and the spaceship is not moving.
4. Send a message to this script component ("#" is shorthand for that) saying "go to" and the clicked position
   as part of the message data.
5. If a "go to" message is received, set the speech label text and then animate the position of the current 
   game object ("." is shorthand for that) to the position send in the message data. When the animation is
   done the function `landed()` is called.
6. When `landed()` is called on animation complete, set the label text, then calculate a position on the
   opposite of the screen and send a message called "go to" to the component "script" in the game object
   "spaceship11". Supplied with the message is the opposite position as message data.
7. If someone sends us a message called "i'm there" we react by just changing the speech label text.   
--]]
```

<!-- basics/parent_child -->

# Parent/child {#examples:basics:parent_child}

This example shows how to child a game object to a parent.

[Project files](https://github.com/defold/examples/tree/master/basics/parent_child)

The parent/child relation is set up right in the editor by placing the parent and child game objects in the same collection and then simply dragging the child game object onto the parent.

Note that such a hierarchy must be created in a collection if you do it in the editor.

## Scripts

### parent.script

```lua
function init(self)
    msg.post(".", "acquire_input_focus") -- <1>

	local pos = go.get_position() -- <2>
	go.animate(".", "position.y", go.PLAYBACK_LOOP_PINGPONG, pos.y + 300, go.EASING_INOUTSINE, 3) -- <3>

	self.has_child = true -- <4>
end


function on_input(self, action_id, action)
    if action_id == hash("touch") and action.pressed then
    	if self.has_child then
			msg.post("child", "set_parent", { keep_world_transform = 1 }) -- <5>
			label.set_text("#label", "Click to child...") -- <6>
		else
			msg.post("child", "set_parent", { parent_id = go.get_id(), keep_world_transform = 1 }) -- <7>
			label.set_text("#label", "Click to detach...") -- <8>
		end
		self.has_child = not self.has_child -- <9>
    end 
end

--[[
1. Tell the engine that this game object wants to receive input.
2. Get the current position.
3. Animate the y position of this game object back and forth.
4. A flag to track if there is a child to this game object or not. Parent-child relations in Defold are only affecting the scene graph so we need to track this ourselves.
5. If the user clicks and there is a child, set the parent to nothing, meaning remove it as a child.
6. Set the label text accordingly.
7. If the user clicks and there is no child, set the parent to this game object.
8. Set the label text accordingly.
9. Set the flag to its inverse.
--]]
```

### child.script

```lua
function init(self)
	go.animate(".", "euler.z", go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_LINEAR, 1) -- <1>
end

--[[
1. Animate the Z component of the euler rotation property on this game object.
--]]
```

<!-- basics/random_numbers -->

# Random numbers {#examples:basics:random_numbers}

This example shows how to generate pseudo-random numbers in Defold using built-in math API.

[Project files](https://github.com/defold/examples/tree/master/basics/random_numbers)

In this example you'll learn how to generate pseudo-random numbers in Defold using built-in math API.

In the example there is only a game object containing:
- *Label* component where we show the text information
- *Script* component where we generate random numbers

Script sets the built-in random generator with a value of os.time() - which should be different every time you run it.
Then produces 3 random numbers using math.random().

For more details refer to Defold API: [https://defold.com/ref/stable/math-lua/#math.random:m-n](https://defold.com/ref/stable/math-lua/#math.random:m-n)

## Scripts

### random_numbers.script

```lua
function init(self)
	local seed = os.time()
	math.randomseed(seed) -- <1>

	label.set_text("#label", "Seed: " .. seed
	.. "\nRandom number (0 - 1): " .. math.random()	 -- <2>
	.. "\nRandom integer (1 - 100): " .. math.random(100)	 -- <3>
	.. "\nRandom integer (-10 - 0): " .. math.random(-10,0))	 -- <4>
end

--[[
1. First, set the randomseed. It can be specific, if you always want to generate same numbers,
	otherwise you can utilise e.g. os.time, like in the example to make it different each time.
2. math.random() with no arguments - generates a random floating point number between 0-1.
3. math.random(X) with one argument - generates an integer between 1 - X.
4. math.random(X, Y) with two arguments - generates an integer between X - Y.
--]]
```

<!-- basics/z_order -->

# Z-order {#examples:basics:z_order}

This example shows how to put sprites in front and behind of eachother

[Project files](https://github.com/defold/examples/tree/master/basics/z_order)

There is one game object containing the logo sprite. It is set at Z position 0.
The green spaceship is another game object containing a sprite. It is set at Z position 0.5.
The pink spaceship is another game object containing a sprite. It is set at Z position -0.5.

## Scripts

### z_order.script

```lua
function init(self)
	go.animate(".", "position.x", go.PLAYBACK_LOOP_PINGPONG, 600, go.EASING_INOUTSINE, 3) -- <1>
end

--[[
1. Animate the game object's ("." is shorthand for the current game object) x position between
   start position and 600.
--]]
```

<!-- collection/proxy -->

# Proxy {#examples:collection:proxy}

This example shows how to use collection proxies to load and unload collections.

[Project files](https://github.com/defold/examples/tree/master/collection/proxy)

The setup consists of several collections and game objects.

proxy.collection
: This is the bootstrap collection specified in `game.project`. Contains:
  - A *Script* that handles loading and unloading of collection proxies
  - Four *Collection proxies* referencing a menu collection and three level collections.

menu.collection
: This collection contains a menu. Contains:
  - A *GUI* with some box and text nodes that acts as buttons.
  - A *GUI script* that handles the logic of clicking on the buttons and sending messages back to the proxy.collection.

level1-3.collection
: Collections representing the levels of a game. Contains:
  - *Script* with logic to send a message back to the proxy.collection to show the menu again.

## Scripts

### controller.script

```lua
local function show(self, proxy) -- <5>
	if self.current_proxy then -- <6>
		msg.post(self.current_proxy, "unload") -- <7>
		self.current_proxy = nil
	end
	msg.post(proxy, "async_load") -- <8>
end

function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.current_proxy = nil -- <2>
	msg.post("#", "show_menu") -- <3>
end

function on_message(self, message_id, message, sender)
	if message_id == hash("show_menu") then -- <4>
		show(self, "#menuproxy")
	elseif message_id == hash("show_level1") then
		show(self, "#level1proxy")
	elseif message_id == hash("show_level2") then
		show(self, "#level2proxy")
	elseif message_id == hash("show_level3") then
		show(self, "#level3proxy")
	elseif message_id == hash("proxy_loaded") then -- <9>
		self.current_proxy = sender -- <10>
		msg.post(sender, "enable") -- <11>
	elseif message_id == hash("proxy_unloaded") then
		print("Unloaded", sender)
	end
end

--[[
1. Acquire input focus for this game object. This is required for input to be able to propagate into any of the collection proxies on the same game object as this script.
2. Create a variable `current_proxy` to track which collection proxy that is loaded.
3. Post a `show_menu` message to the `on_message` function of this script. This load and show the first screen.
4. Message handler that will react to `show_menu`, `show_level1`, `show_level2` and `show_level3` messages and load the appropriate collection proxy.
5. A helper function to unload any currently loaded collection proxy and load a new collection proxy.
6. Check if a collection proxy is loaded.
7. Send an `unload` message to the currently loaded collection proxy. This will immediately unload the proxy and all of its resources. A `proxy_unloaded` message will be sent when it has been unloaded.
8. Send an `async_load` message to the collection proxy that should be loaded. This will start loading the collection proxy and all of its resources. A `proxy_loaded` message will be sent when it has been loaded.
9. Handle the `proxy_loaded` message. This is sent when a collection proxy has finished loading. The collection and all resources will be loaded but no game objects or components will be active/enabled.
10. Store the url of the proxy that was loaded. This is used in the helper function to unload it when showing another collection proxy.
11. Enable the loaded collection proxy. This will activate/enable all game objects and components within the collection.
--]]
```

### menu.gui_script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then -- <2>
		if gui.pick_node(gui.get_node("level1"), action.x, action.y) then -- <3>
			msg.post("proxy:/controller#controller", "show_level1") -- <4>
		elseif gui.pick_node(gui.get_node("level2"), action.x, action.y) then
			msg.post("proxy:/controller#controller", "show_level2")
		elseif gui.pick_node(gui.get_node("level3"), action.x, action.y) then
			msg.post("proxy:/controller#controller", "show_level3")
		end
	end
end

--[[
1. Acquire input focus for this script.
2. Check if a mouse click/screen touch is released.
3. Check if the mouse click/screen touch happened on top of any of the buttons.
4. Send a `show_level1` message to the controller script component in the `proxy` collection.
--]]
```

### level.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus")
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		msg.post("proxy:/controller", "show_menu")
	end
end
```

<!-- collection/splash -->

# Splash {#examples:collection:splash}

This example shows how to use collection proxies to show a splash screen while loading a game menu.

[Project files](https://github.com/defold/examples/tree/master/collection/splash)

The setup consists of several collections and game objects.

splash.collection
: This is the bootstrap collection specified in `game.project`. Contains:
  - A *Script* that handles loading and unloading of collection proxies
  - Two *Collection proxies* referencing the splash screen and a menu collection.

menu.collection
: This collection contains a menu. Contains:
  - A *GUI* with some box and text nodes that acts as buttons.

splashscreen.collection
: Collections representing the splash screen.

## Scripts

### controller.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	msg.post("#splashscreenproxy", "async_load") -- <2>
end

function on_message(self, message_id, message, sender)
	if message_id == hash("proxy_loaded") then -- <3>
		if sender.fragment == hash("splashscreenproxy") then -- <4>
			msg.post("#splashscreenproxy", "enable") -- <5>
			msg.post("#menuproxy", "async_load") -- <6>
			self.menu_loading_started_time = os.time() -- <7>
		elseif sender.fragment == hash("menuproxy") then -- <8>
			local total_menu_loading_time = os.time() - self.menu_loading_started_time
			local minimum_splash_duration = 5
			local delay = math.max(minimum_splash_duration - total_menu_loading_time, 0) -- <9>
			timer.delay(delay, false, function() -- <10>
				msg.post("#splashscreenproxy", "unload") -- <11>
				msg.post("#menuproxy", "enable") -- <12>
			end)
		end
	end
end

--[[
1. Acquire input focus for this game object. This is required for input to be able to propagate into any of the collection proxies on the same game object as this script.
2. Load the splash screen
3. The "proxy_loaded" message is received whenever a collection proxy has been loaded
4. Here we check if it was the splash screen proxy which was loaded
5. Enable the splash screen proxy so that the splash screen is shown
6. Load the menu screen
7. Save the time when the menu screen loading was started
8. Was the menu proxy loaded?
9. Calculate how much longer the splash screen should remain visible, based on how long it took to load the menu
10. Start a timer for the remaining time
11. Unload the splash screen
12. Show the menu
--]]
```

<!-- collection/timestep -->

# Time-step {#examples:collection:timestep}

This example shows how to speed up or slow down animations in a collection proxy by changing the time step of the collection proxy.

[Project files](https://github.com/defold/examples/tree/master/collection/timestep)

The setup consists of a `timestep.collection` and a `game.collection`.

timestep.collection
: This is the bootstrap collection specified in `game.project`. Contains:
  - A *Script* that handles loading of the `game.collection` and controls the time-step of `game.collection` using the `set_time_step` message.

game.collection
: This collection contains a "game" with some animated game objects. Contains:
  - Five animated game objects that are animated using `go.animate()`
  - A *Script* that starts the game object animations and lets the user control the time-step through messages sent to the *Script* in the `timestep.collection`.

## Scripts

### controller.script

```lua
-- speed of the time in the collection proxy
go.property("speed", 1)

function init(self)
	-- acquire input for this script
	msg.post(".", "acquire_input_focus")
	-- load the collection proxy
	msg.post("#gameproxy", "async_load")
end

function update(self, dt)
	-- update the time step of the proxy each frame since it might be animated
	msg.post("#gameproxy", "set_time_step", { factor = self.speed, mode = 0 })
	label.set_text("#label", tostring(self.speed))
end

function on_message(self, message_id, message, sender)
	if message_id == hash("proxy_loaded") then
		msg.post(sender, "enable")
	elseif message_id == hash("animate_speed") then
		-- cancel any current animation of the speed property
		go.cancel_animations("#", "speed")
		-- start animation of the speed property
		local to = message.to
		local change = math.abs(self.speed - to)
		local rate_of_change = 2
		local duration = change / rate_of_change
		go.animate("#", "speed", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_LINEAR, duration)
	elseif message_id == hash("change_speed") then
		-- cancel any current animation of the speed property
		go.cancel_animations("#", "speed")
		-- make sure speed never goes below 0
		self.speed = math.max(self.speed + message.amount, 0)
	end
end
```

### game.script

```lua
function init(self)
	-- get input to this script
	msg.post(".", "acquire_input_focus")

	-- animate some game objects
	go.animate("enemy1", "position.x", go.PLAYBACK_LOOP_PINGPONG, 720, go.EASING_INOUTQUAD, 5, 0)
	go.animate("enemy2", "position.x", go.PLAYBACK_LOOP_PINGPONG, 720, go.EASING_INOUTQUAD, 5, 0.5)
	go.animate("enemy3", "position.x", go.PLAYBACK_LOOP_PINGPONG, 720, go.EASING_INOUTQUAD, 5, 1)
	go.animate("enemy4", "position.x", go.PLAYBACK_LOOP_PINGPONG, 720, go.EASING_INOUTQUAD, 5, 1.5)
end

function on_input(self, action_id, action)
	if action_id == hash("key_left") then
		msg.post("timestep:/controller", "change_speed", { amount = -0.01 })
	elseif action_id == hash("key_right") then
		msg.post("timestep:/controller", "change_speed", { amount = 0.01 })
	elseif action_id == hash("key_space") and action.pressed then
		-- flip self.to between 0 and 3 each time
		self.to = 3 - (self.to or 0)
		msg.post("timestep:/controller", "animate_speed", { to = self.to })
	end
end
```

<!-- debug/physics -->

# Physics debug {#examples:debug:physics}

This example allows you to toggle physics debug visualization as well as changing the time step so the simulation runs at one tenth of the speed.

[Project files](https://github.com/defold/examples/tree/master/debug/physics)

With the physics visualization on, all collision object shapes are visible. In addition, at intersections the normals at the collision points are shown.

The example collection consists of:
- 4 blocks with dynamic collision objects with Restituion 1.0, so they bounce forever,
- 4 walls with static collision objects forming boundaries for the blocks,
- game object `go` with:
  - label with example description,
  - a script `physics.script` included below.

This collection is additionally loaded via a `Collection Proxy` component in `main.collection`. Therefore, sending message `set_time_step` to its url `"main:/loader#physicsproxy"` is causing the proxy to have a different update time, causing e.g. the slow-motion effect, which might be helpful when debugging physics.

## Scripts

### physics.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.show_debug = false -- <2>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		msg.post("@system:", "toggle_physics_debug") -- <3>
		if self.show_debug then -- <4>
			msg.post("main:/loader#physicsproxy", "set_time_step", { factor = 1, mode = 0 })
		else
			msg.post("main:/loader#physicsproxy", "set_time_step", { factor = 0.1, mode = 1 })
		end
		self.show_debug = not self.show_debug -- <5>
	end
end

--[[
1. Make sure this game object's script component gets input from the engine.
2. A state flag to track if we show debug info or not.
3. If user clicks, toggle physics visualization.
4. In addition, we want to set the timestep. That is done through the collection proxy that loaded this example. Since we cannot get hold of the proxy from this side of it we message the loader game object in the main collection and it will relay the message to the proxy component.
5. Switch the `show_debug` flag.
--]]
```

### loader.script

```lua
function init(self)
    msg.post(".", "acquire_input_focus")
    msg.post("#physicsproxy", "load")
end

function on_message(self, message_id, message, sender)
    if message_id == hash("proxy_loaded") then
        msg.post(sender, "init")
        msg.post(sender, "enable")
    end
end
```

<!-- debug/profile -->

# Visual profiler {#examples:debug:profile}

This example shows the on-screen profiler. It displays useful runtime information.

[Project files](https://github.com/defold/examples/tree/master/debug/profile)

For more in-depth analysis, the web profiler is usually more suitable. See [the debug manual](/manuals/debugging) for more information.

## Scripts

### profile.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		msg.post("@system:", "toggle_profile") -- <2>
	end
end

--[[
1. Make sure this game object's script component gets input from the engine.
2. If user clicks, toggle profiling information.
--]]
```

<!-- factory/dynamic -->

# Dynamic factories {#examples:factory:dynamic}

This example shows how to change the prototype game object used by a factory component.

[Project files](https://github.com/defold/examples/tree/master/factory/dynamic)

This example shows how to change the prototype game object used by a factory component. All prototype bullets are stored in a collection and referenced as a collection proxy. The collection proxy is never loaded, but it will ensure that the bullet prototypes are included in the build even though they are not immediately used by a factory. Another alternative is to load bullet prototypes using Live Update.

ship
: The red ship at the bottom. Contains:
  - A *Sprite* component with the spaceship image.
  - A *Factory* component to spawn bullet game objects. This component has the *Dynamic Protoype* option checked.
  - A *Collection Proxy* component referencing a collection containing all bullet types
  - A *Script* component to handle spawning of bullets.

All bullets are added in the bullets.collection:

The bullets.collection is referenced from the dynamic.collection as a collection proxy:

## Scripts

### dynamic.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus")

	-- a list of different bullet prototypes
	self.bullets = {
		"/example/flame.goc",
		"/example/lightning.goc",
		"/example/rock.goc",
	}
	-- the currently used bullet prototype
	self.bullet_index = 1

	-- shoot one bullet per second
	-- animate the bullet up 1000 pixels and then delete it
	timer.delay(0.2, true, function()
		local id = factory.create("#bulletfactory")
		local to = go.get_position(id)
		to.y = to.y + 1000
		go.animate(id, "position", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_LINEAR, 1.5, 0, function()
			go.delete(id)
		end)
	end)
end

function on_input(self, action_id, action)
	-- mouse or spacebar
	if (action_id == hash("touch") or action_id == hash("key_space")) and action.pressed then
		-- next bullet prototype, wrap around to the first
		self.bullet_index = self.bullet_index + 1
		if self.bullet_index > #self.bullets then
			self.bullet_index = 1
		end

		-- unload current prototype
		factory.unload("#bulletfactory")

		-- set a new prototype
		local prototype = self.bullets[self.bullet_index]
		factory.set_prototype("#bulletfactory", prototype)
	end
end
```

<!-- factory/bullets -->

# Shoot bullets {#examples:factory:bullets}

This example shows how to dynamically spawn bullet game objects using a factory component.

[Project files](https://github.com/defold/examples/tree/master/factory/bullets)

This example shows how to dynamically spawn bullet game objects using a factory component and how to also move and delete the bullets. The setup consists of two game objects; one for the player and one for the bullet that is spawned using a factory component.

Combine this example with some of the examples from the movement and physics categories to create a shoot 'em up game!

player
: The red ship at the bottom. Contains:
  - A *Sprite* component with the spaceship image.
  - A *Factory* component to spawn bullet game objects
  - A script to handle spawning of bullets.

bullet
: The bullet fired by the player. Contains:
  - A *Sprite* component with a bullet image.

## Scripts

### player.script

```lua
function init(self)
	-- make sure the script will receive user input
	msg.post(".", "acquire_input_focus")
end

function on_input(self, action_id, action)
	-- mouse or spacebar
	if (action_id == hash("touch") or action_id == hash("key_space")) and action.pressed then
		-- position bullet somewhat offset from the player position
		local pos = go.get_position()
		pos.y = pos.y + 50

		-- spawn a bullet
		local bullet_id = factory.create("#bulletfactory", pos)

		-- animate the bullet
		local distance = 1000                   -- distance in pixels
		local speed = 800                       -- pixels per second
		local duration = distance / speed       -- time in second to travel the full distance
		local to = pos.y + distance
		-- start animation and delete bullet when it has reached its destination
		go.animate(bullet_id, "position.y", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_LINEAR, duration, 0, function()
			go.delete(bullet_id)
		end)
	end
end
```

<!-- factory/spawn_properties -->

# Spawn enemies with script properties {#examples:factory:spawn_properties}

This example shows how to spawn enemy game objects using a factory component with different properties.

[Project files](https://github.com/defold/examples/tree/master/factory/spawn_properties)

This example shows how to dynamically spawn enemy game objects using a factory component with different properties. The setup consists of three main components: a player ship, enemy spawner, and different enemy types with customizable properties.

Press keys `1`, `2`, or `3` to spawn different enemy types.

Example collection consists of 2 game objects:

### Ship
The red ship at the bottom that automatically moves and shoots. Consists of:
- A *Factory* component `bulletfactory` to spawn bullet game objects
- A *Script* `ship` that handles automatic movement (ping-pong animation) and bullet spawning every 0.25 seconds
- A *Sprite* component with the spaceship image

Bullets are simply animated upward and automatically deleted when they reach the top.

### Spawner
Controls enemy spawning with keyboard input. Consists of:
- A *Factory* `enemyfactory` to spawn enemies with different properties
- A *Label* `example_description` with instructions text displayed on top
- A *Script* `spawner` that spawns enemies.

The spawner script defines three different enemy types: `random`, `diagonal`, and `straight`.
Uses factory to create enemies with specific properties:
```lua
local properties = ENEMY_TYPES[enemy_type]
factory.create("#enemyfactory", position, nil, properties)
```

### Enemy Types

**Random Enemy** (Key 1):
- Green UFO sprite
- 1 health point
- Random horizontal movement that changes every second
- Speed: 40 horizontal, -100 vertical

**Diagonal Enemy** (Key 2):
- Red enemy sprite
- 2 health points
- Fixed diagonal movement
- Speed: 120 horizontal, -80 vertical

**Straight Enemy** (Key 3):
- Blue enemy sprite
- 3 health points
- Straight downward movement
- Speed: 0 horizontal, -40 vertical

### Enemy Script Properties
Properties defined in `enemy.script` control enemy behavior:
- `sprite` - Which sprite to display
- `health_points` - How many hits before destruction
- `speed` - Movement velocity vector
- `is_random` - Whether to use random movement changes

When enemies have `go.property` defined in their script, these properties are visible in the *Properties* pane and can be customized per enemy type.

Combine this example with other movement and physics examples to create a complete shoot'em up game!

## Scripts

### ship.script

```lua
function init(self)
	-- Animate automatic player position
	go.animate(".", "position.x", go.PLAYBACK_LOOP_PINGPONG, 620, go.EASING_LINEAR, 6.0)

	-- Create a timer to tick every 0.25 second:
	timer.delay(0.25, true, function()

		-- Create a simple bullet bullet using the factory
		local bullet_id = factory.create("#bulletfactory", go.get_position())

		-- Animate the created bullet towards top of screen, where it is deleted
		if bullet_id then
			go.animate(bullet_id, "position.y", go.PLAYBACK_ONCE_FORWARD, 600, go.EASING_LINEAR, 1, 0, function()
				go.delete(bullet_id)
			end)
		end
	end)
end
```

### enemy.script

```lua
-- Define different properties of the script:
go.property("sprite", hash("ufoGreen"))
go.property("health_points", 1)
go.property("speed", vmath.vector3(100, 100, 0))
go.property("is_random", true)

function init(self)

	-- Set animation of the sprite to the one defined by its property self.sprite:
	sprite.play_flipbook("#sprite", self.sprite)

	-- Add randomness to horizontal direction - this way enemy horizontal speed may be inverted or cleared:
	-- -1 * self.speed.x - inverted direction
	--  0 * self.speed.x - cleared direction
	--  1 * self.speed.x - regular direction
	self.speed.x = math.random(-1, 1) * self.speed.x

	-- If self.is_random boolean property is true:
	if self.is_random then
		-- add a timer to randomly switch horizontal speed every second:
		timer.delay(1, true, function()
			self.speed.x = math.random(-1, 1) * self.speed.x
		end)
	end
end

function update(self, dt)
	-- Update enemy position based on its current speed:
	local pos = go.get_position()
	pos = pos + self.speed * dt
	go.set_position(pos)

	-- Bounce enemy off "walls":
	if pos.x > 600 or pos.x < 50 then
		self.speed.x = -self.speed.x
	end

	-- Remove enemy if it goes out of screen:
	if pos.y < -50 then
		go.delete()
	end
end

function on_message(self, message_id, message, sender)

	-- React to collision with bullet:
	if message_id == hash("trigger_response") and message.enter then

		-- Remove one health point
		self.health_points = self.health_points - 1

		-- Play particlefx for damage taken:
		particlefx.play("#boom")

		-- When no health points left - remove this ship
		if self.health_points <= 0 then
			go.delete()
		end
	end
end
```

### spawner.script

```lua
-- Define different properties for different enemies:
local ENEMY_TYPES = {
	random = {
		sprite = hash("ufoGreen"),
		health_points = 1,
		speed = vmath.vector3(40, -100, 0),
		is_random = true
	},
	diagonal = {
		sprite = hash("enemyRed2"),
		health_points = 2,
		speed = vmath.vector3(120, -80, 0),
		is_random = false
	},
	straight = {
		sprite = hash("enemyBlue4"),
		health_points = 3,
		speed = vmath.vector3(0, -40, 0),
		is_random = false
	}
}

function init(self)
	-- Acquire input focus here, so we can handle inputs:
	msg.post(".", "acquire_input_focus")
end

-- Helper function to spawn given enemy by its type:
local function spawn_enemy(enemy_type)

	-- Select properties of the enemy by type:
	local properties = ENEMY_TYPES[enemy_type]

	-- Set initial position of the spawned ship.
	local position = go.get_position()

	-- This will make the position one out of (-180, -90, 0, 90, 180):
	position.x = position.x + math.random(-2,2) * 90

	-- Create enemy with passed properties
	factory.create("#enemyfactory", position, nil, properties)
end

function on_input(self, action_id, action)

	-- React to different key presses with spawning different enemies:
	if action_id == hash("key_1") and action.released then
		spawn_enemy("random")
	elseif action_id == hash("key_2") and action.released then
		spawn_enemy("diagonal")
	elseif action_id == hash("key_3") and action.released then
		spawn_enemy("straight")
	end
end
```

<!-- factory/basic -->

# Spawn game object {#examples:factory:basic}

This example shows how to dynamically spawn game objects with a factory component.

[Project files](https://github.com/defold/examples/tree/master/factory/basic)

The "debrisfactory" factory component uses the file *debris.go* as prototype, meaning that it produces game objects that are all copies of that file.

## Scripts

### bunny.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then -- <2>
		local pos = vmath.vector3(action.x, action.y, 0) -- <3>
		local carrot_id = factory.create("#carrotfactory", pos) -- <4>
		go.animate(carrot_id, "euler.z", go.PLAYBACK_ONCE_FORWARD, 360, go.EASING_LINEAR, 1, 0, function()   -- <5>
			go.delete(carrot_id)  -- <6>
		end)
	end
end

--[[
1. Acquire input focus so we get input from the engine.
2. If the user clicks.
3. Set the spawning position to the mouse click position.
4. Tell the component "carrotfactory" ("#" denotes a component in the
   current game object) to spawn a game object according to its prototype.
   The function returns the id of the new game object.
5. Rotate the new game object.
6. Delete the game object
--]]
```

### debris.script

```lua
function init(self)
	self.t = 2 -- <1>
end

function update(self, dt)
	self.t = self.t - dt -- <2>
	if self.t < 0 then
		go.delete() -- <3>
	end
end

--[[
1. Store a value `t` in the current script component (`self`).
2. Decrease `t` with delta time (elapsed since last call to `update()`).
3. If `t` is below 0, delete the current game object
   ("." is shorthand for that).
--]]
```

<!-- file/json_load -->

# Load JSON data {#examples:file:json_load}

This example shows how to load json data using sys.load_resource().

[Project files](https://github.com/defold/examples/tree/master/file/json_load)

The example will load a json file. This can be useful for something like level data.

Before we can load a resource we need to tell Defold that we have custom resources.
We do this by changing the "custom resources" entry within our game.project file.

## Scripts

### json_load.script

```lua
local function load_level(level_name)
	local level_path = "/levels/" .. level_name .. ".json" -- <1>
	local data = sys.load_resource(level_path) -- <2>
	local json_data = json.decode(data) -- <3>
	label.set_text("#title", json_data.title) -- <4>
end

function init(self)
	msg.post(".", "acquire_input_focus")
end


function on_input(self, action_id, action)
	if action_id == hash("key_1") then
		if action.released then
			load_level("level_001")
		end
	elseif action_id == hash("key_2") then
		if action.released then
			load_level("level_002")
		end
	end
end

--[[
1. Convinience sake we only want pass in the name of the level, but to load the resource we need to give it the full path.
2. Load the resource, this will return a string.
3. Use the json.decode to make our string into a lua table.
4. Use the loaded level data in whatever way we want.
--]]
```

<!-- file/sys_save_load -->

# Save and Load {#examples:file:sys_save_load}

This example shows how to save and load data using sys.save() and sys.load()

[Project files](https://github.com/defold/examples/tree/master/file/sys_save_load)

The example will save and load a file containing a Lua table with a single value key-value pair representing a highscore. Loading and saving is done using sys.load() and sys.save(). Also refer to the [Working with files manual](https://defold.com/manuals/file-access/).

## Scripts

### sys_save_load.script

```lua
local function load_highscore()
	local filename = sys.get_save_file("sys_save_load", "highscore") -- <1>
	local data = sys.load(filename) -- <2>
	return data.highscore or 0  -- <3>
end

local function save_highscore(highscore)
	local filename = sys.get_save_file("sys_save_load", "highscore")
	sys.save(filename, { highscore = highscore })  -- <4>
end

local function update_labels(score, highscore)
	label.set_text("score#score", tostring(score))
	label.set_text("score#highscore", "HIGH SCORE\n" .. tostring(highscore))
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.score = 0
	self.highscore = load_highscore()
	update_labels(self.score, self.highscore)
end

function update(self, dt)
	if self.pressed then
		self.score = self.score + math.ceil(100 * dt)
		update_labels(self.score, self.highscore)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		if action.pressed then
			self.score = 0
			self.pressed = true
		elseif action.released then
			self.pressed = false
			if self.score > self.highscore then
				self.highscore = self.score
				save_highscore(self.highscore)
				update_labels(self.score, self.highscore)
			end
		end
	end
end

--[[
1. Get an application specific path for the file "highscore"
2. Load saved data.
3. The returned data is a Lua table with the saved values or an empty table if nothing has been saved.
4. Save data. The data to save must be stored in a Lua table.
--]]
```

<!-- gui/button -->

# Button {#examples:gui:button}

A GUI box node with an image texture and a script to make it act as a button.

[Project files](https://github.com/defold/examples/tree/master/gui/button)

The "gui" game object contains a GUI component stored in the file *button.gui*. The GUI contains
the setup with the "button" box node for the button image and the "text" text node for the button label text.

*button.gui* has a script attached to it, called *button.gui_script*, which contains the button logic.

## Scripts

### button.gui_script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then -- <2>
		local button = gui.get_node("button") -- <3>
		local text = gui.get_node("text") -- <4>
		if gui.pick_node(button, action.x, action.y) then -- <5>
			gui.set_text(text, "HELLO!") -- <6>
		else
			gui.set_text(text, "CLICK ME!") -- <7>
		end
	end
end

--[[
1. Tell the engine that this game object wants to receive input.
2. If the user clicks.
3. Get the instance for the node named "button" (the button box).
4. Get the instance for the node named "text" (the button label).
5. Check if the click position (`action.x` and `action.y`) is within the boundaries of 
   the button node.
6. If the user clicks on the button, change the label text.
7. If the user clicks elsewhere, change the label text to something else.
--]]
```

<!-- gui/drag -->

# Drag {#examples:gui:drag}

This example shows how to drag a GUI box node.

[Project files](https://github.com/defold/examples/tree/master/gui/drag)

This example shows how to drag a GUI box node. The example has a list of box nodes that can be dragged. It uses `gui.pick_node()` to detect if a click is within the bounds of a box and then moves the box as long as the mouse button is pressed.

## Scripts

### drag.gui_script

```lua
function init(self)
	msg.post(".", "acquire_input_focus")
	
	-- list of boxes to drag
	self.boxes = {
		gui.get_node("box1"),
		gui.get_node("box2"),
		gui.get_node("box3"),
	}

	-- variable where the currently dragged box is stored
	self.dragged_box = nil
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		-- update the position of the currently dragged box
		if self.dragged_box then
			local mouse_position = vmath.vector3(action.x, action.y, 0)
			gui.set_position(self.dragged_box, mouse_position)
		end

		-- check if the mouse button was pressed
		if action.pressed then
			-- iterate the list of boxes and check if the mouse was
			-- clicked on a box
			for i=1,#self.boxes do
				local box = self.boxes[i]
				-- this will return true if the x and y is within the
				-- bounds of the box
				if gui.pick_node(box, action.x, action.y) then
					-- keep track of the box as being dragged
					self.dragged_box = box
					break
				end
			end
		-- check if the mouse button was released
		-- clear the variable which keeps track of which box is dragged
		elseif action.released then
			self.dragged_box = nil
		end
	end
end
```

<!-- gui/get_set_font -->

# Get and set a gui font resource {#examples:gui:get_set_font}

This example shows how to get and set a font resource on a gui component.

[Project files](https://github.com/defold/examples/tree/master/gui/get_set_font)

## Scripts

### get_set_font.script

```lua
-- create a script resource property 'myfont' referencing a font file
go.property("myfont", resource.font("/assets/text48.font"))

function init(self)
	msg.post(".", "acquire_input_focus")

	-- get the font file on the gui component which is assigned to
	-- the font with id 'default'
	self.default_font = go.get("#gui", "fonts", { key = "default" })
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		-- get the font file currently assigned to the font with id 'default'
		local current_font = go.get("#gui", "fonts", { key = "default" })

		-- toggle between the default font and the font referenced by the
		-- script resource property 'myfont'
		if current_font == self.myfont then
			go.set("#gui", "fonts", self.default_font, { key = "default" })
		else
			go.set("#gui", "fonts", self.myfont, { key = "default" })
		end
	end
end
```

<!-- gui/get_set_material -->

# Get and set a gui material resource {#examples:gui:get_set_material}

This example shows how to get and set a material resource on a gui component.

[Project files](https://github.com/defold/examples/tree/master/gui/get_set_material)

## Scripts

### get_set_material.script

```lua
-- create a script resource property 'myfont' referencing a font file
go.property("mymaterial", resource.material("/example/get_set_material.material"))

function init(self)
	msg.post(".", "acquire_input_focus")

	-- get the material file on the gui component which is assigned to
	-- the material with id 'default'
	self.default_texture = go.get("#gui", "materials", { key = "default" })
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_button_left") and action.pressed then
		-- get the material file currently assigned to the material with id 'default'
		local current_texture = go.get("#gui", "materials", { key = "default" })

		-- toggle between the default material and the material referenced by the
		-- script resource property 'default'
		if current_texture == self.mymaterial then
			go.set("#gui", "materials", self.default_texture, { key = "default" })
		else
			go.set("#gui", "materials", self.mymaterial, { key = "default" })
		end
	end
end
```

<!-- gui/get_set_texture -->

# Get and set a gui texture resource {#examples:gui:get_set_texture}

This example shows how to get and set a texture resource on a gui component.

[Project files](https://github.com/defold/examples/tree/master/gui/get_set_texture)

## Scripts

### get_set_texture.script

```lua
-- create a script resource property 'myatlas' referencing an atlas file
go.property("myatlas", resource.atlas("/example/get_set_texture.atlas"))

function init(self)
	msg.post(".", "acquire_input_focus")

	-- get the atlas file on the gui component which is assigned to
	-- the atlas/texture with id 'ui'
	self.default_atlas = go.get("#gui", "textures", { key = "ui" })
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_button_left") and action.pressed then
		-- get the atlas file currently assigned to the atlas/texture with id 'ui'
		local current_atlas = go.get("#gui", "textures", { key = "ui" })

		-- toggle between the default texture and the texture referenced by the
		-- script resource property 'ui'
		if current_atlas == self.myatlas then
			go.set("#gui", "textures", self.default_atlas, { key = "ui" })
		else
			go.set("#gui", "textures", self.myatlas, { key = "ui" })
		end
	end
end
```

<!-- gui/color -->

# GUI color {#examples:gui:color}

This example shows how change the color of GUI nodes at run-time

[Project files](https://github.com/defold/examples/tree/master/gui/color)

The example shows how to change the color of GUI nodes using `gui.set_color()` and `gui.animate()`.

Nodes will normally inherit the alpha of parent nodes, unless the Inherit Alpha checkbox is unchecked.

## Scripts

### color.gui_script

```lua
function init(self)
	gui.animate(gui.get_node("logo1"), gui.PROP_COLOR, vmath.vector4(1, 0, 0, 1), gui.EASING_INOUTQUAD, 3, 0, nil, gui.PLAYBACK_LOOP_PINGPONG) -- <1>
	gui.animate(gui.get_node("logo2"), "color.x", 0, gui.EASING_INOUTQUAD, 3, 0, nil, gui.PLAYBACK_LOOP_PINGPONG) -- <2>
	gui.animate(gui.get_node("bg"), "color.w", 0, gui.EASING_INOUTQUAD, 4, 0, nil, gui.PLAYBACK_LOOP_PINGPONG) -- <3>
	
	gui.set_color(gui.get_node("logo3"), vmath.vector4(1, 0, 0, 1)) -- <4>

end

--[[
1. x,y,z,w -> r,g,b,a. Keep read and alpha. Animate green and blue to 0.
2. x = red. Animate the red color component to 0.
3. w = alpha. Animate the alpha color component to 0. All children which inherit alpha will be affected.
4. Set the color of the node.
--]]
```

<!-- gui/progress -->

# GUI progress indicators {#examples:gui:progress}

This example shows how to create various types of progress indicators

[Project files](https://github.com/defold/examples/tree/master/gui/progress)

The example shows three different types of progress indicators:

1. A horizontal progress bar created using a box node with a texture and 9-slice scaling
2. A numerical progress text created using a text node
3. A circular progress created using a pie node

## Scripts

### progress.gui_script

```lua
-- set the width of the horizontal progress bar
local function update_horizontal(p)
	local node = gui.get_node("horizontal")
	local size = gui.get_size(node)
	size.x = p * 400 -- max width is 400 pixel
	gui.set_size(node, size)
end

-- set value of numeric progress indicator (in percent from 0% to 100%)
local function update_numeric(p)
	local node = gui.get_node("numeric")
	local percent = math.floor(p * 100)
	gui.set_text(node, tostring(percent) .. "%")
end

-- update radial/circle progress by changing the fill angle
local function update_radial(p)
	local node = gui.get_node("radial")
	local angle = p * 360 -- full circle is 360 degrees
	gui.set_fill_angle(node, angle)
end

function init(self)
	self.time = 0
end

function update(self, dt)
	self.time = self.time + dt

	-- calculate a value between 0.0 and 1.0
	-- the value will gradually increas from 0 to 1 during 3 seconds
	local p = (self.time % 3) / 3
	update_numeric(p)
	update_horizontal(p)
	update_radial(p)
end
```

<!-- gui/healthbar -->

# Health Bar {#examples:gui:healthbar}

This example demonstrates how to add different health bars.

[Project files](https://github.com/defold/examples/tree/master/gui/healthbar)

Overview : Example shows 3 pairs of nodes each forming a "health bar" with different pivots.

Create a pair of Box nodes, so that child node is smaller than the parent:

Example contains 3 such pairs - each with different `Pivot` and `X Anchor` settings for inner health bars:

- `West` + `Left`
- `East` + `Right`
- `Center` + `None`

Health is indicated as the size on X Axis of the inner node, so define what can be maximum and minimum width here.

Create a collection with such GUI component and add it and your game object with script to collection:

Example shows communication between `controller#main` script component (`healthbar.script`) and `hud#main` gui component with gui_script (`healthbar.gui_script`).

## Scripts

### healthbar.script

```lua
function init(self)
	-- < 1 >
	self.player_one_health = 1.0
	self.player_two_health = 1.0
	self.game_boss_health = 1.0

	-- < 2 >
	timer.delay(1, true, function()
		-- < 3 >
		self.player_one_health = math.max(self.player_one_health - 0.1, 0)
		self.player_two_health = math.max(self.player_two_health - 0.1, 0)
		self.game_boss_health = math.max(self.game_boss_health - 0.1, 0)
		-- < 4 >
		msg.post("hud", "update_health", { health_name = "left_health", health_percentage = self.player_one_health })
		msg.post("hud", "update_health", { health_name = "right_health", health_percentage = self.player_two_health })
		msg.post("hud", "update_health", { health_name = "center_health", health_percentage = self.game_boss_health })
	end)
end

--[[
1. Set initial health percentage (1.0 = 100%, 0.0 = 0%).
2. Start a timer that will call every 1 second (first argument) repeateadly (second argument being true) a callback function (3rd argument)
3. Reduce each health percentage by 0.1 (10%), but no less than 0 (using math.max to select `0`, if `self.player_one_health - 0.1` is less than `0`).
4. Send messages to hud (gui component) to "updated_health" with health name and percentage to be set in GUI script.
]]
```

### healthbar.gui_script

```lua
-- < 1 >
local min_size = 48
local max_size = 235 - min_size

-- < 2 >
local function set_healthbar(healthbar_node_name, health_percentage)
	local healthbar_node = gui.get_node(healthbar_node_name)	-- < 3 >
	local healthbar_size = gui.get_size(healthbar_node)			-- < 4 >
	healthbar_size.x = health_percentage * max_size + min_size	-- < 5 >
	gui.set_size(healthbar_node, healthbar_size)				-- < 6 >
end

function init(self)
	-- < 7 >
	set_healthbar("left_health", 1.0)
	set_healthbar("right_health", 1.0)
	set_healthbar("center_health", 1.0)
end

function on_message(self, message_id, message, sender)
	-- < 8 >
	if message_id == hash("update_health") then
		set_healthbar(message.health_name, message.health_percentage)
	end
end

--[[
1. Define minimum and maximum size of GUI healthbar (only width is changed).
2. Define a local helper function to update healthbar.
3. Get node of given name passed as "healthbar_node_name" and store it in local variable "healthbar_node".
4. Get size of this node and store it in local variable "healthbar_size".
5. Change size along X axis (width) of the node to given "health_percentage" scaled times "max_size" and added to "min_size", so that it can be no smaller than it.
6. Set the newly updated size of the node.
7. In init function, for each of three defined nodes set initial health_percentage to 1.0 (100%).
8. In on_message function, if the GUI component receives message "update_health" call helper function to update given health bar.
]]
```

<!-- gui/layouts -->

# Layouts {#examples:gui:layouts}

This example demonstrates the use of layouts.

[Project files](https://github.com/defold/examples/tree/master/gui/layouts)

Overview : A small UI panel that changes its position depending on the screen size (canvas size in HTML5) using the Defold layouts system. [:More on Layouts with Defold:](https://defold.com/manuals/gui-layouts/#layouts)

Layouts are added in the GUI where we want to support them:

The panel is configured in both layouts, Portrait and Landscape:

## Scripts

### layouts.gui_script

```lua
local function set_scores_state(self, score_state)
	gui.set_text(self.ui_elements.num_score, score_state.score)
	gui.set_text(self.ui_elements.num_best, score_state.best_score)
end

function init(self)
	self.current_score_state = {  --  < 1 >
		score = math.random(100, 500),
		best_score = math.random(501, 999)
	}

	self.ui_elements = {}  --  < 2 >
	self.ui_elements.num_score = gui.get_node("num_score")
	self.ui_elements.num_best = gui.get_node("num_best")

	set_scores_state(self, self.current_score_state) --  < 3 >
end

function on_message(self, message_id, message, sender)
	if message_id == hash("layout_changed") then --  < 4 >
		set_scores_state(self, self.current_score_state)
	elseif message_id == hash("update_score") then --  < 5 >
		self.current_score_state.score = self.current_score_state.score + message.score
		if self.current_score_state.score > self.current_score_state.best_score then
			self.current_score_state.best_score = self.current_score_state.score
		end
		set_scores_state(self, self.current_score_state)
	end
end

--[[
1.-It's important to store the state of the UI separately from the view.

2.-Having all the nodes for UI elements makes it easier to work with.

3.-This function updates the view with the current state.

4.-When the layout changes, all the nodes (view) reset to the corresponding layout setup. 
	At this point, we need to restore our state.

5.-External code updates the state, and we apply changes of the state to the view.
--]]
```

<!-- gui/load_texture -->

# Load texture {#examples:gui:load_texture}

This example shows how to load and set a dynamic texture on a gui box node.

[Project files](https://github.com/defold/examples/tree/master/gui/load_texture)

The "gui" game object contains a GUI component stored in the file *load_texture.gui*. The GUI contains the setup with the "button" box node for the button image, the "text" text node for the button label text and the "img" box node for loaded images.

*load_texture.gui* has a script attached to it, called *load_texture.gui_script*, which contains the button logic and logic for loading images.

## Scripts

### load_texture.gui_script

```lua
local function set_message(text)
	gui.set_text(gui.get_node("message"), text) -- <11>
end

local function set_image(self, texture_id, image_data)
	if self.texture_id then -- <8>
		gui.delete_texture(self.texture_id) 
		self.texture_id = nil
	end

	local img = image.load(image_data) -- <9>
	if not img then 
		set_message("Unable to load image")
		return
	end
	
	if gui.new_texture(texture_id, img.width, img.height, img.type, img.buffer) then -- <10>
		self.texture_id = texture_id -- <11>
		gui.set_texture(gui.get_node("img"), texture_id) -- <12>
		set_message("Set new texture")
	else
		set_message("Unable to create texture")
	end
end


local load_image
load_image = function(url)
	http.request(url, "GET", function(self, id, res)  -- <6>
		-- redirect?
		if res.status == 302 or res.status == 301 then -- <7>
			set_message("Redirect: " .. res.headers.location)
			load_image(res.headers.location)
		-- ok or cached?
		elseif res.status == 200 or res.status == 304 then -- <7>
			set_image(self, url, res.response)
		-- error
		else
			set_message("Unable to get image: " .. res.response)
		end
	end)
end

local function load_random(self)
	local url = "https://picsum.photos/id/"..math.random(1, 10).."/200/300.jpg" -- <3>
	set_message("Loading...") -- <4>
	load_image(url) -- <5>
end

function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	load_random(self)	-- <2>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		if gui.pick_node(gui.get_node("button"), action.x, action.y) then -- <13>
			load_random(self) -- <2>
		end
	end
end

--[[
1. Tell the engine that this game object wants to receive input.
2. Start loading random image
3. Generate a URL to a random image
4. Change the label text.
5. Call function load image from URL
6. Make an HTTP request and handle redirects
7. Check server response
8. Remove previous texture if any
9. Create an image resource from loaded image data
10. Create a new texture using image resource
11. Save the texture id 
12. Set new texture as node texture
13. Check if the click position (`action.x` and `action.y`) is within the boundaries of 
   the button node.
--]]
```

<!-- gui/pointer_over -->

# Pointer over {#examples:gui:pointer_over}

A GUI box node with an image texture and a script that react when pointer over this node.

[Project files](https://github.com/defold/examples/tree/master/gui/pointer_over)

The "gui" game object contains a GUI component stored in the file *pointer_over.gui*. The GUI contains
the setup with the "button" box node for the button image and the "text" text node for the button label text.

*pointer_over.gui* has a script attached to it, called *pointer_over.gui_script*, which contains the button logic.

## Scripts

### pointer_over.gui_script

```lua
function init(self)
  msg.post(".", "acquire_input_focus") -- <1>
  self.button = gui.get_node("button") -- <2>
  self.text = gui.get_node("text") -- <3>
  self.is_over = false -- <4>
end

function on_input(self, action_id, action)
  if action_id == nil then --<5>
    if gui.pick_node(self.button, action.x, action.y) then -- <6>
      if not self.is_over then
        gui.set_text(self.text, "HELLO!") -- <7>
        self.is_over = true
      end
    else
      if self.is_over then
        gui.set_text(self.text, "BUTTON") -- <8>
        self.is_over = false
      end
    end
  end
end

--[[
1. Tell the engine that this game object wants to receive input.
2. Get the instance for the node named "button" (the button box).
3. Get the instance for the node named "text" (the button label).
4. Trigger for locking multiple execution.
5. If action_id equal nil (pointer is moving)
6. Check if the pointer position (`action.x` and `action.y`) is within the boundaries of
   the button node.
7. Change the label text in pointer over case.
8. Change the label text to default value.
--]]
```

<!-- gui/slice9 -->

# Slice-9 {#examples:gui:slice9}

This example demonstrates slice-9 scaling gui box node.

[Project files](https://github.com/defold/examples/tree/master/gui/slice9)

Overview : Using a small stylized image (90x91 pixels) we apply it to a gui node and set the slice-9 properties, we can then
adjust the size and retain the styling without streching and distortion. [:More on Slice-9 with Defold:](https://defold.com/manuals/gui-box/#slice-9-texturing)

The setup consists of a gui collection, gui script, a box node and a texture atlas

Box Node
: contains:
  - A texture set to stylized wood plank image.
  - Size Mode set to Manual
  - Slice 9 adjusted settings

Gui script
: Use:
  - For animating the node to different sizes, showing slice-9 at its potential.

## Scripts

### slice9.gui_script

```lua
local shape1 = vmath.vector3(660,576,0)  --  < 1 >
local shape2 = vmath.vector3(150,500,0)
local shape3 = vmath.vector3(350,250,0)

local function getshape(self)  --  < 2 >
	local node = gui.get_node("slice_box")
	local function animate_size(node, shape)  --  < 3 >
		gui.animate(node, "size", shape, gui.EASING_INOUTCUBIC, 1.75, 2.5, getshape, gui.PLAYBACK_ONCE_FORWARD)
	end
	if self.shape_number == 1 then
		animate_size(node, shape1)
		self.shape_number = 2
	elseif self.shape_number == 2 then
		animate_size(node, shape2)
		self.shape_number = 3
	else
		animate_size(node, shape3)
		self.shape_number = 1
	end
end

function init(self)  --  < 4 >
	self.shape_number = 1
	getshape(self)
end

--[[

1.-Here we create 3 local vector3's representing 3 different sizes for use when animating
	the gui node size property.

2.-getshape() function gets our slice-9 gui node then an if statement is used to check
	the shape_number variable and animate_size is set accordingly and shape_number is
	changed for the next shape.

3.-The function animate_size() takes in the node and shape vector3 and uses them
	with gui.animate. Here we animate the "size" of the node and after the animation is
	complete getshape function is called again and a different shape "size" will be animated
	once again.

4.-In the initialize function we set self.shape_number to 1 and call getshape function to
	start the looping chained animation.

--]]
```

<!-- gui/stencil -->

# Stencil {#examples:gui:stencil}

A GUI box node with "Clipping mode" set to "STENCIL". This makes it mask its child node (which is called "bunny").

[Project files](https://github.com/defold/examples/tree/master/gui/stencil)

## Scripts

### stencil.gui_script

```lua
function init(self)
	local bunny = gui.get_node("bunny")
	gui.animate(bunny, "position.x", 150, gui.EASING_INOUTSINE, 3, 0, null, gui.PLAYBACK_LOOP_PINGPONG)
end
```

<!-- input/move -->

# 8 ways movement {#examples:input:move}

A very simple 8 ways movement setup with a single game object and a script that listens to input and updates the game object position accordingly.

[Project files](https://github.com/defold/examples/tree/master/input/move)

## Scripts

### move.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.vel = vmath.vector3() -- <2>	
end

function update(self, dt)
	local pos = go.get_position() -- <3>
	pos = pos + self.vel * dt -- <4>
	go.set_position(pos) -- <5>
	
	self.vel.x = 0 -- <6>
	self.vel.y = 0
end

function on_input(self, action_id, action)
	if action_id == hash("up") then
		self.vel.y = 150 -- <7>
	elseif action_id == hash("down") then
		self.vel.y = -150
	elseif action_id == hash("left") then
		self.vel.x = -150 -- <8>
	elseif action_id == hash("right") then
		self.vel.x = 150
	end
end

--[[
1. Tell the engine that the current game object ("." is 
   shorthand for that) should receive user input to the function
   `on_input()` in its script components.
2. Construct a vector to indicate velocity. It will initially be
   zero.
3. Each frame, get the current position and store in `pos`.
4. Add the velocity, scaled to the current frame length. Velocity
   is therefore expressed in pixels per second.
5. Set the game object's position to the newly calculated position.
6. Zero out the velocity. If no input is given, there should be
   no movement.
7. If the user presses "up", set the y component of the velocity to 150.
   If the user presses "down", set the y component to -150.
8. Similarly, if the user presses "left", set the x component of the velocity to -150.
   And finally, if the user presses "right", set the x component to 150.
--]]
```

<!-- input/down_duration -->

# Down duration {#examples:input:down_duration}

Listens to input trigger "touch" and count mouse down duration in update method.

[Project files](https://github.com/defold/examples/tree/master/input/down_duration)

## Scripts

### down_duration.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.message = "Duration: %f . Last duration: %f" -- <2>
	self.duration = 0
	self.last_duration = 0
end

local function update_text(self) -- <3>
	local msg = string.format(self.message, self.duration, self.last_duration) -- <4>
	label.set_text("#label", msg) -- <5>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then -- <6>
		if action.pressed then -- <7>
			self.is_start_timer = true -- <8>
		elseif action.released then -- <9>
			self.is_start_timer = false -- <10>
			self.last_duration = self.duration -- <11>
			self.duration = 0
			update_text(self) -- <12>
		end
	end
end

function update(self, dt)
	if self.is_start_timer then -- <13>
		self.duration = self.duration + dt -- <14>
		update_text(self) -- <15>
	end
end

--[[
1. Tell the engine that this object ("." is shorthand for the current game object) wants to receive input. The function `on_input()` will be called whenever input is received.
2. Prepare format of output including two float placeholders.
3. Create method for updating the text label.
4. Create a formatted string from the format and duration and last_duration arguments.
5. Set the label component to the stored text.
6. Check if we receive an input action named "touch".
7. Check if it is pressed then run the following.
8. Change flag for starting a timer.
9. Check if it is released then run the following.
10. Change flag for stopping a timer.
11. Save duration as last_duration.
12. Run method for updating text.
13. Check if timer is started.
14. Add dt (delta time from the last frame) to the duration variable.
15. Run method for updating text.
--]]
```

<!-- input/entity_picking -->

# Entity Picking {#examples:input:entity_picking}

This example demonstrates how to pick a game object from the 3D scene.

[Project files](https://github.com/defold/examples/tree/master/input/entity_picking)

This example describes method of selecting a game object from the 3D scene on the click of the mouse using collision-based picking:

* We use [collision object components](https://defold.com/manuals/physics-objects/) to define a pickable shape for each relevant game object. This example uses 3D physics, which is enabled in the `game.project` file.
* When the user clicks the mouse button, we convert screen coordinates to world coordinates and fire a raycast into the 3D world using the `physics.raycast()` function.
* If the ray intersects with a collision object, the corresponding game object is considered "picked".

The models used in this example are from Kenney's [Prototype Kit](https://kenney.nl/assets/prototype-kit), licensed under CC0.

## Scripts

### entity_picking.script

```lua
go.property("camera_url", msg.url("/camera#camera"))

--- Performs a raycast from the camera through a screen position to find an entity.
-- @param camera_url url The camera URL to use for screen-to-world conversion
-- @param screen_x number The x-coordinate on the screen
-- @param screen_y number The y-coordinate on the screen
-- @param collision_groups table The collision groups to check against as array of hash values
-- @return table|nil The first entity hit by the ray, or nil if nothing was hit
local function pick_entity(camera_url, screen_x, screen_y, collision_groups)
	local from = camera.screen_to_world(vmath.vector3(screen_x, screen_y, 0), camera_url)
	local to = camera.screen_to_world(vmath.vector3(screen_x, screen_y, 100), camera_url)
	local results = physics.raycast(from, to, collision_groups, { all = false })
	if not results then
		return nil
	end

	return results[1]
end

function init(self)
	-- Use the projection provided by the camera
	msg.post("@render:", "use_camera_projection")

	-- Acquire input focus to receive input events
	msg.post(".", "acquire_input_focus")

	self.input_pressed = false -- Tracks if the input is currently pressed
	self.last_input = nil      -- Stores the last input action received
	self.previous = nil        -- Keeps track of the previously highlighted entity
end

function update(self, dt)
	if not self.last_input then
		-- No input received yet
		return
	end

	local result = pick_entity(self.camera_url, self.last_input.screen_x, self.last_input.screen_y, { hash("target") })
	if result then
		-- Store in the result table the model URL of the entity just for convenience
		result.model_url = msg.url(nil, result.id, "model")

		-- Set the tint of the entity to highlight it
		go.set(result.model_url, "tint.w", 1.5)

		-- If the input is currently pressed, move the camera to the entity
		if self.input_pressed then
			-- We want to move the camera to only the X,Y of the entity, so we get its position
			local move_to = go.get("/camera", "position")
			move_to.x = result.position.x
			move_to.y = result.position.y

			go.cancel_animations("/camera", "position")
			go.animate("/camera", "position", go.PLAYBACK_ONCE_FORWARD, move_to, go.EASING_INOUTQUAD, 0.5)
		end

		-- If the previously highlighted entity is different from the current entity, reset its tint
		if self.previous and self.previous.id ~= result.id then
			go.set(self.previous.model_url, "tint.w", 1)
		end
		self.previous = result
	else
		-- No entity was hit, so reset the tint of the previously highlighted entity
		if self.previous then
			go.set(self.previous.model_url, "tint.w", 1)
			self.previous = nil
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		-- "touch" is a screen touch or mouse click. We only want to react to the press event.
		self.input_pressed = action.pressed
	elseif not action_id then
		-- If action_id is nil, it means that the action is a mouse move event.
		-- "action" contains the mouse move event data. We want to store it for later use.
		self.last_input = action
	end
end
```

<!-- input/mouse_and_touch -->

# Mouse and touch events {#examples:input:mouse_and_touch}

Shows how to read mouse/touch movement and mouse/touch button state.

[Project files](https://github.com/defold/examples/tree/master/input/mouse_and_touch)

## Scripts

### mouse_and_touch.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.state = "-"
end

function on_input(self, action_id, action)
	local pos = vmath.vector3(action.x, action.y, 0) -- <2>
	if action_id == hash("touch") then  -- <3>
		if action.pressed then -- <4>
			self.state = "pressed"
		elseif action.released then -- <5>
			self.state = "-"
		end
	end
	local text = ("x: %d y: %d state: %s"):format(pos.x, pos.y, self.state)
	label.set_text("#label", text)
end

--[[
1. Tell the engine that this object ("." is shorthand for the current game object) wants to receive input. The function `on_input()` will be called whenever input is received.
2. Read the position of the mouse pointer or touch event
3. The left mouse button in the input bindings will also be used for touch events on a phone/tablet
4. The 'pressed' state will be true on the frame when the mouse button/finger is pressed
5. The 'released' state will be true on the frame when the mouse button/finger is released
--]]
```

<!-- input/text -->

# Text input {#examples:input:text}

Listens to text input trigger "type" and modifies the game object label with the alien's speech according to input. A "backspace" key trigger has also been added.

[Project files](https://github.com/defold/examples/tree/master/input/text)

## Scripts

### text.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.message = "" -- <2>
end

function on_input(self, action_id, action)
	if action_id == hash("type") then
		self.message = self.message .. action.text -- <3>
		label.set_text("#label", self.message) -- <4>
	elseif action_id == hash("backspace") and action.repeated then
		local l = string.len(self.message)
		self.message = string.sub(self.message, 0, l-1) -- <5>
		label.set_text("#label", self.message) -- <6>
	end
end

--[[
1. Tell the engine that this object ("." is shorthand for the current game object) wants to receive input. The function `on_input()` will be called whenever input is received.
2. Store a variable in the script component with the text that the user types.
3. If the "type" text trigger action is sent, add the typed text to the variable `message` that stores the text.
4. Set the label component to the stored text.
5. If the user presses <kbd>backspace</kbd>, set the stored text to a substring starting at the beginning of the stored text and ending at the length of the stored text minus 1. This erases the last character from the stored text.
6. Set the label component to the stored text.
--]]
```

<!-- material/custom_sprite -->

# Custom Sprite {#examples:material:custom_sprite}

This example demonstrates a simple way to create and apply a custom sprite shader for changing colors and customizing an outline.

[Project files](https://github.com/defold/examples/tree/master/material/custom_sprite)

If your game requires a sprite that can be recolored and reused, a custom shader will be needed. Your sprite's artwork can be composed in such a way that will help achieve things you may want to do. For example an outline around your sprite that can be turned off/on and color changed. When creating your artwork if your sprite's green-channel is shifted slightly below 1.0 and you add an outline around your sprite with full green color equal to 1.0 then in the shader you can manage the green channel values that match 1.0 and change the color or completely hide these values thus removing the outline altogether. Recoloring sprites to be used throughout a game is pretty common. One way to achieve re-coloring with a range of values instead of a single color is to de-saturate a part of the sprite you want to recolor. When you de-saturate an image it will even out the red, green and blue channel values to a grey-scale. You can then check in the shader for these grey-scale values and change the colors. To check for these values you can add 2 or 3 channels together as a float value and then with another float multiply a single channel by 2 or 3, we then compare these values when valid use a new color.

In the example the custom sprite material has 2 vertex attributes each is a vector 4 of float values. The values are used for coloring the fluid and the outline from a script to the shader. The script has a function for creating a random color and also sets the color vertex properties

## Scripts

### set_color.script

```lua
local sprite_to_color = "/new#sprite" local brightness = 0.3

local function random_color(self) -- create a new_color of random-ish float values (0.3 or 1.3)
	local random_number_r = math.random(0, 1)+brightness
	local random_number_b = math.random(0, 1)+brightness
	local random_number_g = math.random(0, 1)+brightness
	local new_color = vmath.vector4(random_number_r, random_number_g, random_number_b, self.outline_io)
	return new_color
end

function init(self)
	msg.post("@render:", "clear_color", { color = vmath.vector4(0.25960784,0.2315686274509804,0.229607843, 1.0) } )
	
	self.outline_io = 0.0 -- float is used when setting the w value of the material vertex attribute "outline" 0.0 = off 1.0 = on
	
	math.randomseed(socket.gettime()*10000)

end

function on_message(self, message_id, message)

	if message_id == hash("outline_io") then

		if self.outline_io <= 0.0 then
			self.outline_io = 1.0 
		else 
			self.outline_io = 0.0 
		end
		go.set(sprite_to_color, "outline.w", self.outline_io)

	elseif message_id == hash("outline_color") then

		go.set(sprite_to_color, "outline", random_color(self)) -- set color for outline

	elseif	message_id == hash("fluid_color") then

		go.set(sprite_to_color, "newcolor", random_color(self)) -- set color for potion fluid

	end

end
```

### recolor.fp

```glsl
#version 140

uniform sampler2D texture_sampler;
uniform f_uniform
{
    vec4 tint;
};

in vec2 var_texcoord0;
// custom vertex attributes
in vec4 new_color;
in vec4 new_outline;

out vec4 final_color;

void main()
{
    lowp vec4 tint_pm = vec4(tint.xyz * tint.w, tint.w);
    lowp vec4 sprite = texture(texture_sampler, var_texcoord0.xy);

    // float values used for comparing
    lowp float combine = (sprite.r + sprite.g);
    lowp float greenmul = sprite.g * 2;

    // when 2 channels added together equal the same as a single channel multipled then we have desaturated values
    if(combine == greenmul){
        sprite = vec4(sprite.rgb*new_color.rgb,sprite.a);
    }

    // when the green channel has a value of 1.0 and the w value is 1.0(on) then we color the outline
    if(new_outline.w >= 1.0 && sprite.g >= 1.0){
        sprite = vec4(new_outline.rgb,1.0);
    }
    else if (sprite.g >= 1.0){ //when the w value is not 1.0 we remove all values. turning the outline off
        sprite = vec4(0.0, 0.0, 0.0, 0.0);
    }
    
    final_color = vec4(sprite * tint);
}
```

### recolor.vp

```glsl
#version 140

uniform v_inputs
{
    mat4 view_proj;
};
// positions are in world space
in vec4 position;
in vec2 texcoord0;
// custom vertex attributes from material
in vec4 newcolor;
in vec4 outline;

out vec2 var_texcoord0;
// custom vertex attributes sent to fragment program
out vec4 new_color;
out vec4 new_outline;

void main()
{
    gl_Position = view_proj * vec4(position.xyz, 1.0);
    var_texcoord0 = texcoord0;
    new_color = newcolor;
    new_outline = outline;
}
```

<!-- material/noise -->

# Noise shader {#examples:material:noise}

This example shows how to use a noise function to generate clouds, smoke or similar effect using a shader.

[Project files](https://github.com/defold/examples/tree/master/material/noise)

This example contains a game object with a model component. The model component uses the `/builtins/assets/meshes/quad.dae` mesh, which is a rectangle 1 by 1 unit large. The game object is scaled to the dimensions of the screen so that the mesh covers the entire screen.

The shader applies multiple layers of noise to the uv coordinate to create a two dimensional flowing cloud or smoke like look. The shader also receives a time value from `noise.script` and applies this in the calculation to apply movement to the visual effect.

## Scripts

### noise.script

```lua
function init(self)
	self.time = 0
end

function update(self, dt)
	self.time = self.time + dt
	-- set the x component of the 'time' fragment constant in the material
	go.set("#model", "time.x", self.time)
end
```

### noise.fp

```glsl
#version 140

in mediump vec2 var_texcoord0;

uniform fs_uniforms
{
    mediump vec4 time;
};

out mediump vec4 out_fragColor;

// noise shader from https://www.shadertoy.com/view/XXBcDz

// pseudo random generator (white noise)
float rand(vec2 n)
{ 
    return fract(sin(dot(n, vec2(12.9898, 78.233))) * 43758.5453);
}

// value noise
float noise(vec2 p)
{
    vec2 ip = floor(p);
    vec2 u = fract(p);
    u = u * u * (3.0 - 2.0 * u);

    float x = mix(rand(ip),                  rand(ip + vec2(1.0, 0.0)), u.x);
    float y = mix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x);
    float a = u.y;
    float res = mix(x, y, a);
    return res * res;
}

// used to rotate domain of noise function
const mat2 rot = mat2( 0.80,  0.60, -0.60,  0.80 );

// fast implementation
float fbm( vec2 p )
{
    float f = 0.0;
    f += 0.500000 * noise( p ); p = rot * p * 2.02;
    f += 0.031250 * noise( p ); p = rot * p * 2.01;
    f += 0.250000 * noise( p ); p = rot * p * 2.03;
    f += 0.125000 * noise( p + 0.1 * sin(time.x) + 0.8 * time.x ); p = rot * p * 2.01;
    f += 0.062500 * noise( p + 0.3 * sin(time.x) ); p = rot * p * 2.04;
    f += 0.015625 * noise( p );
    return f / 0.96875;
}
    
void main()
{  
    float n = fbm(var_texcoord0.xy);
    out_fragColor = vec4(n, n, n, 1.0);
}
```

<!-- material/repeating_background -->

# Repeating Background {#examples:material:repeating_background}

Create a scrolling background using a repeating texture on a model quad.

[Project files](https://github.com/defold/examples/tree/master/material/repeating_background)

A repeating, scrolling texture can add visual interest to a static background. This example demonstrates how to create an infinitely tiling background using a model quad with a repeating texture. The effect is achieved by scrolling the UV coordinates over time, creating smooth, continuous motion.

The script driving the effect works as follows:

* Each frame it reads the current window size and scales the `background` game object so the quad covers the full viewport. The rotation is set via `euler.z` (Rotation Z in the IDE).
* It converts the window size into a UV repeat scale (`uv_params.x/y`) so the texture tiles across the screen.
* It advances a scrolling offset based on `scroll_speed` and `tile_size`, wraps it to the 0..1 range, and sends `uv_params` to the model material.

The asset used in this example is from Kenney's [Puzzle Pack 2](https://www.kenney.nl/assets/puzzle-pack-2), licensed under CC0.

## Scripts

### repeating_background.script

```lua
-- Size of a single tile in pixels
go.property("tile_size", 128)
-- Scroll speed vector (x, y, z) in pixels per second
go.property("scroll_speed", vmath.vector3(50, 0, 0))

-- Applies layout based on current window size
-- Scales the game object to fill the entire window and calculates UV scale
local function apply_layout(self)
	local width, height = window.get_size()
	-- Scale the game object to match window dimensions
	go.set(".", "scale", vmath.vector3(width, height, 1))

	-- Calculate how many tiles fit in the window (for UV tiling)
	self.uv_scale = vmath.vector3(width / self.tile_size, height / self.tile_size, 0)

	-- Send UV parameters to the shader: scale (x, y) and offset (z, w)
	local uv_params = vmath.vector4(self.uv_scale.x, self.uv_scale.y, self.offset.x, self.offset.y)
	go.set("#model", "uv_params", uv_params)
end

-- Updates UV offset for scrolling animation
-- Moves the texture offset based on scroll speed and wraps it using modulo
local function update_uv_params(self, dt)
	-- Calculate offset delta in tile units (0-1 range)
	local delta = self.scroll_speed * dt / self.tile_size
	-- Update offset (subtract because we want to scroll in the direction of scroll_speed)
	self.offset = self.offset - delta
	-- Wrap offset to 0-1 range to create seamless repeating
	self.offset.x = self.offset.x % 1
	self.offset.y = self.offset.y % 1

	-- Send updated UV parameters to the shader
	local uv_params = vmath.vector4(self.uv_scale.x, self.uv_scale.y, self.offset.x, self.offset.y)
	go.set("#model", "uv_params", uv_params)
end

-- Initialize the script
-- Sets up the initial UV offset to zero
function init(self)
	self.offset = vmath.vector3(0)
end

function final(self)
end

-- Update function called every frame
-- Applies layout and updates UV parameters for scrolling
function update(self, dt)
	apply_layout(self)
	update_uv_params(self, dt)
end
```

### repeating_background.vp

```glsl
#version 140

in vec4 position;
in vec2 texcoord0;
uniform vp_uniforms
{
    mat4 mtx_worldview;
    mat4 mtx_proj;
    vec4 uv_params;
};

out vec2 var_texcoord0;

void main()
{
    // uv_params.x = repeat scale on U axis (tiles across width)
    // uv_params.y = repeat scale on V axis (tiles across height)
    // uv_params.z = scroll offset on U axis (normalized 0..1)
    // uv_params.w = scroll offset on V axis (normalized 0..1)
    var_texcoord0 = texcoord0 * uv_params.xy + uv_params.zw;
    gl_Position = mtx_proj * mtx_worldview * vec4(position.xyz, 1.0);
}
```

### repeating_background.fp

```glsl
#version 140

in mediump vec2 var_texcoord0;

out vec4 out_fragColor;

uniform mediump sampler2D texture0;

void main()
{
    out_fragColor = texture(texture0, var_texcoord0);
}
```

<!-- material/screenspace -->

# Screenspace {#examples:material:screenspace}

This example shows how to create a custom material with two textures that blend together to create a pattern effect using screen space coordinates.

[Project files](https://github.com/defold/examples/tree/master/material/screenspace)

In this example, we create a new material for 3D models in which we convert vertex coordinates to screenspace to get a special effect. It may be called "surface fill", "screenspace fill" and is used, most often in combination with outlines, to highlight objects in 3D games or indicate their status.

We added two game objects and two models to which we assigned our new `screenspace` material. The material is based on [`unlit`](/examples/material_unlit/), but in it:
- vertex shader: we added a conversion of the clip space position to the screen position to pass that value to the fragment shader.
- fragment shader: we added sampling the color based on screenspace coordinates and blending into the final output color.
- material properties: we added a new sampler to set a second texture to be used as a pattern, and user-defined uniforms to control the fragment shader.

The last important thing is to pass the screen size to the shader to adjust the aspect ratio:
```lua
local w, h = window.get_size()
go.set("#model", "screen_size", vmath.vector4(w, h, 0, 0))
```

The shaders are written in GLSL 1.40, which is available from Defold 1.9.2. The model used in this example is from Kenney's [Prototype Pack](https://kenney.nl/assets/prototype-kit), licensed under CC0.

## Scripts

### screenspace.script

```lua
function init(self)
	self.time = 0 -- for pattern animation

	-- The model with the pattern - we enabled the effect, 0.5 is the intensity (alpha)
	go.set("/crate_selected#model", "pattern_opts.x", 0.5)
	-- + add 70 degrees to the rotation
	go.set("/crate_selected#model", "pattern_opts.w", math.rad(70))

	-- The normal model - the 0.0 value disables the effect
	go.set("/crate#model", "pattern_opts.x", 0)
end

function update(self, dt)
	-- Animate the pattern by changing the z value
	self.time = self.time - dt
	go.set("/crate_selected#model", "pattern_opts.z", self.time)

	-- The shader uses the screen size to calculate the aspect ratio.
	-- In a real game, you'd set this in the render script globally for all materials.
	local w, h = window.get_size()
	go.set("/crate_selected#model", "screen_size", vmath.vector4(w, h, 0, 0))
end
```

### screenspace.vp

```glsl
#version 140

// The model's vertex position and texture coordinates.
in vec4 position;
in vec2 texcoord0;

// The projection, view and world matrices.
uniform general_vp
{
    mat4 mtx_world;
    mat4 mtx_view;
    mat4 mtx_proj;
};

// The output of a vertex shader are passed to the fragment shader.
// The texture coordinates of the vertex.
out vec2 var_texcoord0;

// The screen texture coordinates of the vertex.
out vec4 var_screen_texcoord;

// Converts the clip space position to the screen position.
vec4 clip_to_screen(vec4 pos)
{
    // Position is [-w,w], convert to [-0.5w,0.5w]
    vec4 o = pos * 0.5;

    // Convert from [-0.5w + 0.5w,0.5w + 0.5w] to [0,w]
    o.xy = vec2(o.x, o.y) + o.w;

    // Keep "zw" as it is
    o.zw = pos.zw;
    return o;
}

void main()
{
    // Pass the texture coordinates to the fragment shader.
    var_texcoord0 = texcoord0;

    // Transform the vertex position to clip space.
    vec4 vertex_pos = mtx_proj * mtx_view * mtx_world * vec4(position.xyz, 1.0);
    gl_Position = vertex_pos;

    // Convert the clip space position to the screen position and pass the value to the fragment shader.
    var_screen_texcoord = clip_to_screen(vertex_pos);
}
```

### screenspace.fp

```glsl
#version 140

// Inputs should match the vertex shader's outputs.
in vec2 var_texcoord0;
in vec4 var_screen_texcoord;

// The color texture.
uniform lowp sampler2D texture0;
// The pattern texture.
uniform lowp sampler2D texture_pattern;

// The user defined uniforms.
uniform user_fp
{
    // pattern_opts.x - alpha, default 1.0 (set 0.0 to disable the screen space effect).
    // pattern_opts.y - scale, default 30.0.
    // pattern_opts.z - offset by x, default 0.0.
    // pattern_opts.w - rotation in radians.
    vec4 pattern_opts;

    // The screen size, used to calculate the aspect ratio.
    vec4 screen_size;
};

// The final color of the fragment.
out lowp vec4 final_color;

// Rotate 2D vector "v" by the "a" angle in radians
vec2 rotate(vec2 v, float a)
{
    float s = sin(a);
    float c = cos(a);
    return mat2(c, s, -s, c) * v;
}

void main()
{
    // Sample the color texture at the fragment's texture coordinates.
    vec4 color = texture(texture0, var_texcoord0.xy);

    // Counteract the perspective correction and scale the coords.
    vec2 pattern_coord = (var_screen_texcoord.xy / var_screen_texcoord.w) * pattern_opts.y;
    // + Correct the aspect ratio
    float aspect = screen_size.x / screen_size.y;
    pattern_coord.x *= aspect;
    // + Offset the grid horizontally
    pattern_coord.x += pattern_opts.z;
    // + Rotate
    pattern_coord = rotate(pattern_coord, pattern_opts.w);

    // Output the sampled color
    if (pattern_opts.x > 0.0)
    {
        // Sample the pattern at the screen space texture coordinates.
        vec4 pattern_color = texture(texture_pattern, pattern_coord);

        // Blend the colors: (sRGBA*1) + (dRGBA*(1-sA))
        final_color = pattern_color * pattern_opts.x + color * (1.0 - (pattern_color.a * pattern_opts.x));
    }
    else
    {
        // No pattern, just output the color.
        final_color = color;
    }
}
```

<!-- material/sprite_local_uv -->

# Sprite local UV {#examples:material:sprite_local_uv}

This example shows how to get local UV coordinates of a sprite regardless of sprite size

[Project files](https://github.com/defold/examples/tree/master/material/sprite_local_uv)

The example uses two game objects, each with a sprite component and a script.

The sprite component uses a custom sprite material `sprite_local_uv.material` with `local_position` and `sprite_size` as two vertex attributes. The `local_position` attribute is of semantic type "Position" and coordinate space "Local" while the `sprite_size` attribute is of semantic type "User" and will be set by the script.

The script gets the size of the sprite and sets it as the `sprite_size` vertex attribute.

## Scripts

### sprite_local_uv.script

```lua
function init(self)
	-- get the sprite size from the sprite component propertry 'size'
	local size = go.get("#sprite", "size")

	-- set the size on the sprite material in the custom vertex attribute 'sprite_size'
	go.set("#sprite", "sprite_size", size)

	-- rotate the sprite
	go.animate(".", "euler.z", go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_LINEAR, 5)
end
```

### sprite_local_uv.vp

```glsl
#version 140

// positions are in world space
in highp vec4 position;
in mediump vec2 texcoord0;

// position in local space
in highp vec2 position_local;
// size of sprite in pixels
in mediump vec2 sprite_size;

out mediump vec2 var_texcoord0;
out highp vec2 var_position_local;

uniform vs_uniforms
{
    highp mat4 view_proj;
};

void main()
{
    gl_Position = view_proj * vec4(position.xyz, 1.0);
    var_texcoord0 = texcoord0;
    // calculate normalized local position and pass it on to the fragment program
    var_position_local = (position_local + sprite_size * 0.5) / sprite_size;
}
```

### sprite_local_uv.fp

```glsl
#version 140

// from sprite_local_uv.vp
in mediump vec2 var_texcoord0;
in highp vec2 var_position_local;

out vec4 out_fragColor;

uniform mediump sampler2D texture_sampler;
uniform fs_uniforms
{
    mediump vec4 tint;
};

void main()
{
    // Pre-multiply alpha since all runtime textures already are
    mediump vec4 tint_pm = vec4(tint.xyz * tint.w, tint.w);

    // sample color from sprite texture
    vec4 color = texture(texture_sampler, var_texcoord0.xy) * tint_pm;

    // mix local position with red and green color of sprite to
    // create a gradient across the entire sprite
    out_fragColor.rg = mix(color.rg, var_position_local.xy, 0.3);
    // use blue and alpha from the sprite
    out_fragColor.b = color.b;
    out_fragColor.a = color.a;
}
```

<!-- material/vertexcolor -->

# Sprite Vertex Color Attribute {#examples:material:vertexcolor}

This example shows how to set and animate a vertex attribute

[Project files](https://github.com/defold/examples/tree/master/material/vertexcolor)

The `vertexcolor.script` sets the vertex attribute "mycolor", which has been specified in the material.

The shaders specified by the material also makes use of the `mycolor` attribute to colorize the sprites.

The vertex attributes can also be animated. Click the image for an animation effect.

## Scripts

### vertexcolor.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus")
	
	local scale = 0.75
	local spacingx = 160 * scale + 10
	local spacingy = 190 * scale + 10
	local startx = 40 + spacingx*0.5
	local starty = 40 + spacingy*0.5

	local maxy = 3
	local maxx = 4

	self.urls = {}

	-- 1. For all sprites in the example we set a slightly different `mycolor` vertex attribute:
	for y = 0, maxy do
		for x = 0, maxx do
			local p = vmath.vector3(startx + x*spacingx, starty + y*spacingy, 0.5)
			local id = factory.create("#factory", p, nil, nil, vmath.vector3(0.8, 0.8, 1))
			local url = msg.url(nil, id, "sprite")
			table.insert(self.urls, url)

			-- set vertex attribute:
			go.set(url, "mycolor", vmath.vector4(x/maxx, y/maxy, 0, 1))
		end
	end

	self.updated = false
	self.animation_finished = true
end

function update(self, dt)
	self.updated = true
end

function on_input(self, action_id, action)

	-- 2. On click we animate the `mycolor` vertex attribute of each of the sprites to blue and back.
	if action_id == hash("touch") and action.pressed and self.updated and self.animation_finished then
		for _, url in ipairs(self.urls) do
			self.animation_finished = false

			-- animate vertex attribute:
			go.animate(url, "mycolor", go.PLAYBACK_ONCE_PINGPONG, vmath.vector4(0, 0, 1, 1), go.EASING_LINEAR, 1, 0, function()
				self.animation_finished = true
			end)
		end
	end
end
```

### vertexcolor.vp

```glsl
#version 140

// positions are in world space
in highp vec4 position;
in mediump vec2 texcoord0;
in mediump vec4 mycolor; // 1. Add attribute definition

out mediump vec2 var_texcoord0;
out mediump vec4 var_mycolor; // 2. Add output variable to pass color to fp

uniform vs_uniforms
{
    highp mat4 view_proj;
};

void main()
{
    gl_Position = view_proj * vec4(position.xyz, 1.0);
    var_texcoord0 = texcoord0;
    var_mycolor = mycolor; // 3. Pass mycolor attribute value to fp.
}
```

### vertexcolor.fp

```glsl
#version 140

in mediump vec2 var_texcoord0;
in mediump vec4 var_mycolor; // 4. Add var_mycolor definition

out vec4 out_fragColor;

uniform mediump sampler2D texture_sampler;

void main()
{
    // Pre-multiply color to match premultiplied textures
    mediump vec4 tint_pm = vec4(var_mycolor.rgb * var_mycolor.a, var_mycolor.a);
    out_fragColor = texture(texture_sampler, var_texcoord0.xy) * tint_pm;
}
```

<!-- material/unlit -->

# Unlit {#examples:material:unlit}

This example demonstrates how to create and apply an custom non-lit material to a 3D model.

[Project files](https://github.com/defold/examples/tree/master/material/unlit)

In industry-established terms, a material that is not affected by lighting is called "unlit" or "non-lit". It is used to create retro-style graphics or for effects that should not depend on lighting (headlights, lamps).

This example contains a game object with a model that has an `unlit` material applied to it. The material is assigned custom vertex and fragment shaders. The shader is very simple and just transfers the texture color to the model. This is an excellent starting point for creating new materials and for creating effects that do not depend on lighting. The shaders are written in GLSL 1.40, which is available from Defold 1.9.2.

The model used in this example is from Kenney's [Train Pack](https://kenney.nl/assets/train-kit), licensed under CC0.

## Scripts

### unlit.vp

```glsl
#version 140

// The model's vertex position and texture coordinates.
in vec4 position;
in vec2 texcoord0;

// The model's world matrix.
in mat4 mtx_world;

// The projection and view matrices.
uniform general_vp
{
    mat4 mtx_view;
    mat4 mtx_proj;
};

// The output of a vertex shader are passed to the fragment shader.
// The texture coordinates of the vertex.
out vec2 var_texcoord0;

void main()
{
    // Pass the texture coordinates to the fragment shader.
    var_texcoord0 = texcoord0;

    // Transform the vertex position to clip space.
    gl_Position = mtx_proj * mtx_view * mtx_world * vec4(position.xyz, 1.0);
}
```

### unlit.fp

```glsl
#version 140

// Inputs should match the vertex shader's outputs.
in vec2 var_texcoord0;

// The texture to sample.
uniform lowp sampler2D texture0;

// The final color of the fragment.
out lowp vec4 final_color;

uniform fs_uniforms
{
    mediump vec4 tint;
};

void main()
{
    // Pre-multiply alpha since all runtime textures already are
    vec4 tint_pm = vec4(tint.xyz * tint.w, tint.w);

    // Sample the texture at the fragment's texture coordinates.
    vec4 color = texture(texture0, var_texcoord0.xy) * tint_pm;

    // Output the sampled color.
    final_color = color;
}
```

<!-- material/uvgradient -->

# UV Gradient {#examples:material:uvgradient}

This example shows how to apply a basic shader to a full screen quad.

[Project files](https://github.com/defold/examples/tree/master/material/uvgradient)

This example contains a game object with a model component. The model component uses the `/builtins/assets/meshes/quad.dae` mesh, which is a rectangle 1 by 1 unit large. The game object is scaled to the dimensions of the screen so that the mesh covers the entire screen.

The shader is very basic and sets the fragment color based on the UV position, thus creating a color gradient. This is a good starting point when experimenting with graphical effects using a shader.

## Scripts

### uvgradient.fp

```glsl
varying mediump vec2 var_texcoord0;

void main()
{  
    gl_FragColor = vec4(var_texcoord0.x, var_texcoord0.y, 0.5, 1.0f);
}
```

<!-- mesh/triangle -->

# Mesh {#examples:mesh:triangle}

This example shows how to create a basic mesh component in the shape of a triangle.

[Project files](https://github.com/defold/examples/tree/master/mesh/triangle)

This example contains a game object with a mesh component in the shape of a triangle. The triangle is defined in `triangle.buffer` as the three points of the triangle in the `position` stream. The triangle also defines the colors at each point. The colors get mixed automatically when the triangle is drawn by the shader.
```
[
    {
        "name": "position",
        "type": "float32",
        "count": 3,
        "data": [
            -0.5, -0.5, 0,
            0.5, -0.5, 0,
            0.0, 0.5, 0
        ]
    },
    {
        "name": "color0",
        "type": "float32",
        "count": 4,
        "data": [
            0, 1, 0, 1,
            1, 0, 0, 1,
            0, 0, 1, 1
        ]
    }
]
```

## Scripts

### mesh.fp

```glsl
varying mediump vec4 var_color;

void main()
{
	gl_FragColor = var_color;
}
```

### mesh.vp

```glsl
uniform mediump mat4 mtx_worldview;
uniform mediump mat4 mtx_proj;

attribute mediump vec4 position;
attribute mediump vec4 color0;

varying mediump vec4 var_color;

void main()
{
	gl_Position = mtx_proj * mtx_worldview * vec4(position.xyz, 1.0);
	var_color = color0;
}
```

<!-- model/aabb -->

# AABB {#examples:model:aabb}

This example demonstrates how to use the `model.get_aabb()` function in a 3D scene.

[Project files](https://github.com/defold/examples/tree/master/model/aabb)

This example shows how to work with Axis-Aligned Bounding Boxes (AABB) in a 3D scene. The setup consists of falling cubes that are dynamically tracked by a camera using their combined bounding box. The example demonstrates:

* How to create and manage a dynamic bounding box that updates with moving objects
* Using `model.get_aabb()` to get object bounds
* Camera positioning based on bounding box size
* Dynamic object spawning with factory
* Smooth camera transitions

Press SPACE or click to spawn new cubes. The camera will automatically adjust to keep all objects in view based on their combined bounding box.

The models used in this example are from Kenney's [Prototype Kit](https://kenney.nl/assets/prototype-kit), licensed under CC0.

## Scripts

### aabb.script

```lua
--
-- Dynamic bounding box - it tracks the bounding box of the objects in the scene
--

--- Create a new instance
-- @return table - the bounding box instance
local function bbox_new()
	return {
		objects = {}, -- dict for iteration
		count = 0,
		min = vmath.vector3(),
		max = vmath.vector3()
	}
end

--- Add an object to the bounding box
-- @param bbox table - the bounding box instance
-- @param obj_id hash - the object id
-- @param aabb table - the aabb of the object
local function bbox_add(bbox, obj_id, aabb)
	if not aabb then
		aabb = model.get_aabb(msg.url(nil, obj_id, "model"))
	else
		assert(types.is_vector3(aabb.min) and types.is_vector3(aabb.max), "AABB is not valid")
	end

	local entry = {
		id = obj_id,
		position = go.get_position(obj_id),
		aabb = aabb
	}
	bbox.objects[obj_id] = entry
	bbox.count = bbox.count + 1
end

--- Remove an object from the bounding box
-- @param bbox table - the bounding box instance
-- @param obj_id hash - the object id
local function bbox_remove(bbox, obj_id)
	bbox.objects[obj_id] = nil
	bbox.count = bbox.count - 1
end

--- Update the bounding box
-- @param bbox table - the bounding box instance
local function bbox_update_all(bbox)
	bbox.min = vmath.vector3()
	bbox.max = vmath.vector3()
	for _, entry in pairs(bbox.objects) do
		local pos = go.get_position(entry.id)
		entry.position = pos

		bbox.min.x = math.min(bbox.min.x, entry.aabb.min.x + pos.x)
		bbox.min.y = math.min(bbox.min.y, entry.aabb.min.y + pos.y)
		bbox.min.z = math.min(bbox.min.z, entry.aabb.min.z + pos.z)
		bbox.max.x = math.max(bbox.max.x, entry.aabb.max.x + pos.x)
		bbox.max.y = math.max(bbox.max.y, entry.aabb.max.y + pos.y)
		bbox.max.z = math.max(bbox.max.z, entry.aabb.max.z + pos.z)
	end
end

--- Compute the bounding box
-- @param bbox table - the bounding box instance
-- @return table - result with {center, min, max, radius}
local function bbox_compute(bbox)
	local center = (bbox.min + bbox.max) * 0.5
	local radius = vmath.length(bbox.max - bbox.min) * 0.5
	return {
		center = center,
		min = bbox.min,
		max = bbox.max,
		radius = radius
	}
end

--
-- Helper functions
--

--- Add a cube to the scene
-- @param self table - the script instance
-- @param x number - the x coordinate
-- @param y number - the y coordinate
-- @param z number - the z coordinate
-- @param color string - the color of the cube - "red" or "white"
local function add_cube(self, x, y, z, color)
	if self.bbox.count >= sys.get_config_int("model.max_count") then
		print("Increase `model.max_count` and `physics.max_collision_object_count` values!")
		return
	end

	local url = color == "red" and "#factory_box2" or "#factory_box1"
	local obj_id = factory.create(url, vmath.vector3(x, y, z))
	bbox_add(self.bbox, obj_id)

	go.animate(msg.url(nil, obj_id, "model"), "tint.w", go.PLAYBACK_ONCE_BACKWARD, 3, go.EASING_INQUAD, 0.5)
end

--
-- Main script
--

function init(self)
	-- Acquire input focus to receive input events
	msg.post(".", "acquire_input_focus")

	-- Get the camera default rotation
	self.camera_euler = go.get("/camera", "euler")

	-- Create a new dynamic bounding box instance
	self.bbox = bbox_new()

	-- Add some cubes to the scene at (0, 1-5, 0) coordinates
	for i = 1, 10 do
		local cube_color = i % 2 == 0 and "red" or "white"
		add_cube(self, (math.random() - 0.5) * 0.1, i / 2, (math.random() - 0.5) * 0.1, cube_color)
	end
	bbox_update_all(self.bbox)

	-- Compute the initial bounding box data
	self.view = bbox_compute(self.bbox)
end

function update(self, dt)
	bbox_update_all(self.bbox)

	-- Current bounding box data
	local current = bbox_compute(self.bbox)

	-- Animate the values for smooth camera movement
	local t = 0.05
	self.view.center = vmath.lerp(t, self.view.center, current.center)
	self.view.radius = vmath.lerp(t, self.view.radius, current.radius)

	-- Calculate camera position and rotation
	local camera_yaw = vmath.quat_rotation_y(math.rad(self.camera_euler.y))
	local camera_pitch = vmath.quat_rotation_x(math.rad(self.camera_euler.x))
	local camera_rotation = camera_yaw * camera_pitch
	local camera_zoom = 1.05 * self.view.radius / math.tan(0.5 * go.get("/camera#camera", "fov"))
	local camera_position = self.view.center + vmath.rotate(camera_rotation, vmath.vector3(0, 0, camera_zoom))
	go.set("/camera", "position", camera_position)
	go.set("/camera", "rotation", camera_rotation)

	-- Uncomment to benchmark
	-- add_cube(self, math.random(-3, 3), 10, math.random(-3, 3))
	-- add_cube(self, math.random(-3, 3), 10, math.random(-3, 3), "red")
end

function on_input(self, action_id, action)
	-- Add a cube to the scene when the mouse button / space key is pressed
	if (action_id == hash("touch") or action_id == hash("key_space")) and action.pressed then
		local colors = {"red", "white"}
		add_cube(self, (math.random() - 0.5) * 0.5, 10, (math.random() - 0.5) * 0.5, colors[math.random(1, 2)])
	end
end
```

<!-- model/character -->

# Character {#examples:model:character}

This example shows how to view and play skeletal animations on a glTF model.

[Project files](https://github.com/defold/examples/tree/master/model/character)

The setup consists of one `player` game object with a `model`, `camera` and `script` component. The `model` component uses "Knight.glb" and "knight_texture.png". The "Knight.glb" file contains meshes and animation data. The `player.script` is used to play different animations from "Knight.glb".

The model and assets are [made by Kay Lousberg](https://kaylousberg.com/game-assets/).

## Scripts

### player.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus")
	model.play_anim("#model", "T-Pose", go.PLAYBACK_LOOP_FORWARD)

	-- enabled and disable meshes to get the correct look
	-- weapons
	model.set_mesh_enabled("#model", "1H_Sword", true)
	model.set_mesh_enabled("#model", "1H_Sword_Offhand", false)
	model.set_mesh_enabled("#model", "2H_Sword", false)

	-- equipment
	model.set_mesh_enabled("#model", "Knight_Helmet", true)
	model.set_mesh_enabled("#model", "Knight_Cape", true)

	-- different shields
	model.set_mesh_enabled("#model", "Spike_Shield", true)
	model.set_mesh_enabled("#model", "Round_Shield", false)
	model.set_mesh_enabled("#model", "Rectangle_Shield", false)
	model.set_mesh_enabled("#model", "Badge_Shield", false)
end

function on_input(self, action_id, action)
	if action_id == hash("key_1") then
		model.play_anim("#model", "Idle", go.PLAYBACK_LOOP_FORWARD)
	elseif action_id == hash("key_2") then
		model.play_anim("#model", "Walking_A", go.PLAYBACK_LOOP_FORWARD)
	elseif action_id == hash("key_3") then
		model.play_anim("#model", "1H_Melee_Attack_Chop", go.PLAYBACK_LOOP_FORWARD)
	elseif action_id == hash("key_4") then
		model.play_anim("#model", "Block", go.PLAYBACK_LOOP_FORWARD)
	elseif action_id == hash("key_5") then
		model.play_anim("#model", "Cheer", go.PLAYBACK_LOOP_FORWARD)
	end
end
```

<!-- model/cubemap -->

# Cubemap Reflection {#examples:model:cubemap}

This example shows how to use a cubemap to draw environment reflections on a model.

[Project files](https://github.com/defold/examples/tree/master/model/cubemap)

This example contains a game object with a model component in the shape of the Defold logo. The model has a special `cubemap_model.material` which uses a cubemap sampler to calculate reflections on the model from the cubemap.

## Scripts

### cubemap.script

```lua
local ZOOM_SPEED = 0.1
local ROTATION_SPEED = 1

function init(self)
	msg.post("@render:", "use_camera_projection")
	msg.post(".", "acquire_input_focus")
	self.yaw            = 0   -- for camera rotation
	self.pitch          = 0   -- for camera rotation
	self.zoom           = 5   -- default zoom
	self.zoom_offset    = 0   -- modification from default zoom
end

function update(self, dt)
	local camera_yaw           = vmath.quat_rotation_y(math.rad(self.yaw))
	local camera_pitch         = vmath.quat_rotation_x(math.rad(self.pitch))
	local camera_rot           = camera_yaw * camera_pitch
	local camera_position      = vmath.rotate(camera_rot, vmath.vector3(0, 0, self.zoom + self.zoom_offset))
	go.set_position(camera_position)
	go.set_rotation(camera_rot)

	local cameraposv4 = vmath.vector4(camera_position.x, camera_position.y, camera_position.z, 1)
	go.set("logo#model", "cameraPosition", cameraposv4)
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		self.yaw   = self.yaw   - action.dx * ROTATION_SPEED
		self.pitch = self.pitch + action.dy * ROTATION_SPEED
	elseif action_id == hash("mouse_wheel_up") then
		self.zoom_offset = self.zoom_offset - ZOOM_SPEED
	elseif action_id == hash("mouse_wheel_down") then
		self.zoom_offset = self.zoom_offset + ZOOM_SPEED
	end
end
```

### cubemap_model.fp

```glsl
varying mediump vec3 vReflect;

uniform samplerCube envMap;

void main() {
	gl_FragColor = textureCube(envMap, vReflect);
}
```

### cubemap_model.vp

```glsl
uniform mediump mat4 view_proj;
uniform mediump mat4 world;
uniform mediump mat4 normal_transform;
uniform mediump mat4 world_view;
uniform mediump vec4 cameraPosition;

attribute mediump vec3 position;
attribute mediump vec3 normal;
attribute mediump vec2 texcoord0;

varying mediump vec3 vReflect;

void main()
{
	vec4 worldP = world * vec4(position, 1.0);
	gl_Position = view_proj * worldP;
	
	vec3 worldNormal = normalize(normal);
	vec3 cameraToVertex = normalize( worldP.xyz - cameraPosition.xyz );
	vReflect = reflect( cameraToVertex, worldNormal );
}
```

<!-- model/gltf -->

# GLTF {#examples:model:gltf}

This example demonstrates how to use a glTF model.

[Project files](https://github.com/defold/examples/tree/master/model/gltf)

This example demonstrates how to use glTF models to add a toy car on the scene with a track and animates environment around the car.

The models used in this example are from Kenney's [Toy Car Kit](https://kenney.nl/assets/toy-car-kit), licensed under CC0.

## Scripts

### gltf.script

```lua
-- This script controls the movement of track parts to create an infinite scrolling effect
-- i.e. we don't move the car, we move the track.

function init(self)
	local count = 6       -- Total number of track parts
	local part_size = 4   -- Size of each track part

	self.current_z = 0    -- Current z position of the track
	self.loop_at_z = part_size * (count - 2)  -- Point at which to loop the track

	self.speed = 5        -- Movement speed of the track
end

function update(self, dt)
	-- Move the track forward based on speed and delta time
	self.current_z = self.current_z + self.speed * dt

	-- Loop the track position when it reaches the loop point
	if self.current_z > self.loop_at_z then
		self.current_z = self.current_z - self.loop_at_z
	end

	-- Update the position of the track game object
	go.set("/track", "position.z", self.current_z)
end
```

<!-- model/skinning -->

# GPU Skinning {#examples:model:skinning}

This example demonstrates GPU skinning.

[Project files](https://github.com/defold/examples/tree/master/model/skinning)

This example shows how the `model_skinned_instanced.material` is used to render and animate many instances of the same model efficiently using instancing and GPU skinning.

Model from the [Universal Animation Library](https://quaternius.itch.io/universal-animation-library).

<!-- model/modelvertexcolor -->

# Model Vertex Color {#examples:model:modelvertexcolor}

This example demonstrates how to apply a vertex color shader using exported attributes from a 3D model.

[Project files](https://github.com/defold/examples/tree/master/model/modelvertexcolor)

Vertex color attributes are usually made up as a vector4 of floats represented as rgba(red, green, blue, alpha) channels. They can be applied to 3d models and exported from many 3d editor applications and are commonly used in games for many effects. This example we are displaying a 3d model with vertex color attribute through a shader. No textures or uv's are used to display the colors.

A game object with a model that has a `vertexcolor` material applied to it. The material is assigned custom vertex and fragment shaders. The shader is very simple and just transfers the vertex color data from the model to the vertex and fragment program to display them. The shaders are written in GLSL 1.40, which is available from Defold 1.9.2.

## Scripts

### vertexcolor.vp

```glsl
#version 140

// Models vertex color attribute comes in as rgba floats (vec4)
in vec4 color;

// The model's vertex position.
in vec4 position;

// The model's world matrix.
in mat4 mtx_world;

// The projection and view matrices.
uniform general_vp
{
    mat4 mtx_view;
    mat4 mtx_proj;
};

// The output of a vertex shader are passed to the fragment shader.
out vec4 vertex_color;

void main()
{
    // Setting the vertex colors to the passed varying.
    vertex_color = color;

    // Transform the vertex position to clip space.
    gl_Position = mtx_proj * mtx_view * mtx_world * vec4(position.xyz, 1.0);
}
```

### vertexcolor.fp

```glsl
#version 140

// Inputs should match the vertex shader's outputs.
in vec4 vertex_color;

// The final color of the fragment.
out lowp vec4 final_color;

uniform fs_uniforms
{
    mediump vec4 tint;
};

void main()
{
    // brightening up the displayed vertex colors
    lowp float brightness = 0.1;
    // Pre-multiply alpha for tint
    vec4 tint_pm = vec4(tint.xyz * tint.w, tint.w);

    // Sample the vertex color from vertices, add a little brightness with tint.
    vec4 color = vertex_color + brightness * tint_pm ;

    // Output the sampled color.
    final_color = color;
}
```

<!-- model/skybox -->

# Skybox {#examples:model:skybox}

This example shows how to create a skybox using a cubemap texture.

[Project files](https://github.com/defold/examples/tree/master/model/skybox)

This example shows how to create a skybox. A skybox is a technique that makes the scene look bigger and more impressive by wrapping the viewer with a texture that goes around the camera 360 degrees.

An in-depth explanation of skybox rendering can be found in [Tutorial 25 of OGL Dev](https://www.ogldev.org/www/tutorial25/tutorial25.html).

One of the key components of a skybox is the cubemap texture. A cubemap is a texture that contains 6 individual 2D textures that each form one side of a cube: a textured cube.

The cubemap is projected on a sphere or a cube positioned in such a way that the camera and other objects are placed inside the cubemap:

Skybox texture by Jockum Skoglund aka hipshot. Free to use.

## Scripts

### skybox.fp

```glsl
#version 140

in mediump vec3 var_texcoord0;

uniform samplerCube cubemap;

void main()
{
	gl_FragColor = texture(cubemap, var_texcoord0);
}
```

### skybox.vp

```glsl
#version 140

uniform vs_uniforms
{
	uniform mediump mat4 view_proj;
	uniform mediump mat4 world;
};

in highp vec3 position;

out mediump vec3 var_texcoord0;

void main()
{
	/*
	 * Transform the position vector using the world view projection matrix
	 * and override the Z component with the W component. After the vertex
	 * shader is complete the rasterizer takes gl_Position vector and performs
	 * perspective divide (division by W) in order to complete the projection.
	 * When we set Z to W we guarantee that the final Z value of the position
	 * will be 1.0. This Z value is always mapped to the far Z. This means that
	 * the skybox will always fail the depth test against the other models in
	 * the scene. That way the skybox will only take up the background left
	 * between the models and everything else will be infront of it.
	 */
	mat4 wvp = world * view_proj;
	vec4 wvp_pos = wvp * vec4(position, 1.0);
	gl_Position = wvp_pos.xyww;

	/*
	 * Use the original position in object space as the 3D texture coordinate.
	 * This makes sense because the way sampling from the cubemap works is by
	 * shooting a vector from the origin through a point in the box or sphere.
	 * So the position of the point actually becomes the texture coordinate.
	 * The vertex shader passes the object space coordinate of each vertex as
	 * the texture coordinate and it gets interpolated by the rasterizer for
	 * each pixel. This gives us the position of the pixel which we can use for
	 * sampling.
	 */
	var_texcoord0 = position;
}
```

<!-- movement/3d_fps -->

# First-person 3D camera and movement {#examples:movement:3d_fps}

Control a first-person camera using WASD and mouse to look with cursor lock.

[Project files](https://github.com/defold/examples/tree/master/movement/3d_fps)

This example shows how to build a simple first-person controller for a 3D scene. You can look around with the mouse and move on the XZ plane using the keyboard (WSAD).

## What you'll learn?
- How to implement a FPP camera with mouse to look around.
- How to lock/unlock the mouse cursor for immersive camera control.
- How to move on a simple XZ plane logic with keyboard input.

## Controls
| Input                  | Action                                               |
|------------------------|------------------------------------------------------|
| Left mouse click       | Lock the cursor and enable mouse look                |
| Mouse movement         | Rotate camera                                        |
| `Esc`                  | Unlock the cursor                                    |
| `W`/`S`/`A`/`D`        | Move forward/backward/left/right on the ground plane |

## How it works?
When the cursor is locked, the script reads mouse movement deltas and rotates the camera accordingly. Movement is normalized to keep a consistent speed in all directions and is clamped within a square area so you cannot wander off the demo scene.

Example collection consists of 3 main parts:

- `character` - The player character game object includes:
  - A *script* `character_controller.script` component that implements mouse look, cursor lock/unlock, and WASD movement.
  - A *camera* component configured with perspective projection.

- `scene` - the models used to create a basic 3D environment:
  - Ground plane scaled to form a walkable area with prototype texture
  - Walls built from simple cube models with prototype textures
  - Some decorative trees

- `gui` - An on-screen GUI with short instructions.

### Assets
Tree models with textures by Kay Louseberg: https://kaylousberg.itch.io/kaykit-forest
Prototype textures for Defold by Visionaire: https://github.com/Thevisionaire1/3Deforms

## Script

Tuning parameters are defined at the top of `character_controller.script`:
- `look_sensitivity` (degrees per pixel) controls how fast the camera rotates
- `move_speed` (world units per second) controls walking speed
- `move_limit` (half-size in world units) clamps movement within bounds

## Scripts

### character_controller.script

```lua
-- First-person 3D camera controller

-- Tuning parameters
local look_sensitivity = 0.15 -- degrees of camera rotation per 1 pixel of mouse movement
local move_speed = 0.5        -- world units per second for camera movement on XZ plane
local move_limit = 1.25       -- bounds (half-size) for camera movement on XZ to keep it in a square area

function init(self)
	-- Acquire input focus to receive input events from the engine
	msg.post(".", "acquire_input_focus")

	-- Mouse lock state: when true, mouse deltas rotate the camera
	self.mouse_locked = false

	-- Initialize yaw/pitch from current rotation (stored in degrees in Defold)
	self.yaw = go.get(".", "euler.y")
	self.pitch = go.get(".", "euler.x")

	-- Input state for continuous movement (WASD)
	self.input = {
		forward = false,
		backward = false,
		left = false,
		right = false,
	}
end

function update(self, dt)
	-- Clamp pitch to avoid flipping the camera upside down
	if self.pitch > 89 then self.pitch = 89 end
	if self.pitch < -89 then self.pitch = -89 end

	-- Apply rotation directly via Euler angles (in degrees)
	go.set(".", "euler", vmath.vector3(self.pitch, self.yaw, 0))

	-- Build desired movement direction on XZ plane from input flags
	local x = (self.input.right and 1 or 0) - (self.input.left and 1 or 0)
	local z = (self.input.backward and 1 or 0) - (self.input.forward and 1 or 0)

	-- If there is any movement input, move the camera
	if x ~= 0 or z ~= 0 then
		-- Local space direction (camera space)
		local local_dir = vmath.vector3(x, 0, z)
		local len = math.sqrt(local_dir.x * local_dir.x + local_dir.z * local_dir.z)

		if len > 0 then
			-- Normalize to keep speed consistent diagonally
			local_dir.x = local_dir.x / len
			local_dir.z = local_dir.z / len

			-- Convert the yaw to a quaternion
			local q_yaw = vmath.quat_rotation_y(math.rad(self.yaw))

			-- Convert local movement to world space using current yaw
			local world_dir = vmath.rotate(q_yaw, local_dir)

			-- Get the current position of the character
			local pos = go.get_position()

			-- Integrate the position
			pos.x = pos.x + world_dir.x * move_speed * dt
			pos.z = pos.z + world_dir.z * move_speed * dt

			-- Clamp the position within the square bounds
			if pos.x > move_limit then pos.x = move_limit end
			if pos.x < -move_limit then pos.x = -move_limit end
			if pos.z > move_limit then pos.z = move_limit end
			if pos.z < -move_limit then pos.z = -move_limit end

			-- Set the new position
			go.set_position(pos)
		end
	end
end

-- Pre-hashed input action ids (must match project input bindings)
local KEY_W = hash("key_w")
local KEY_S = hash("key_s")
local KEY_A = hash("key_a")
local KEY_D = hash("key_d")
local KEY_ESC = hash("key_esc")
local TOUCH = hash("touch")
local MOUSE_BUTTON_1 = hash("mouse_button_1")

function on_input(self, action_id, action)
	-- Mouse look when locked: engine provides action.dx/dy even while cursor is locked
	if self.mouse_locked and (action.dx or action.dy) then
		-- Rotate the camera based on the mouse movement
		self.yaw = self.yaw - (action.dx or 0) * look_sensitivity
		self.pitch = self.pitch + (action.dy or 0) * look_sensitivity
	end

	-- Lock on first click (touch or left mouse button)
	if not self.mouse_locked and action.pressed
		and (action_id == TOUCH or action_id == MOUSE_BUTTON_1) then
		-- Lock the mouse
		window.set_mouse_lock(true)
		self.mouse_locked = true
	end

	-- WSAD - Continuous movement input state (pressed/released)
	if action_id == KEY_W then
		-- Set the forward input flag to true if the W key is pressed
		if action.pressed then self.input.forward = true end
		if action.released then self.input.forward = false end
	end
	if action_id == KEY_S then
		-- Set the backward input flag to true if the S key is pressed
		if action.pressed then self.input.backward = true end
		if action.released then self.input.backward = false end
	end
	if action_id == KEY_A then
		-- Set the left input flag to true if the A key is pressed
		if action.pressed then self.input.left = true end
		if action.released then self.input.left = false end
	end
	if action_id == KEY_D then
		-- Set the right input flag to true if the D key is pressed
		if action.pressed then self.input.right = true end
		if action.released then self.input.right = false end
	end

	-- ESC unlocks the mouse so the cursor is free again
	if action_id == KEY_ESC and action.pressed then
		-- Unlock the mouse
		window.set_mouse_lock(false)
		self.mouse_locked = false
	end
end
```

<!-- movement/follow -->

# Follow input {#examples:movement:follow}

This example shows how to make a game object continuously follow the mouse.

[Project files](https://github.com/defold/examples/tree/master/movement/follow)

## Scripts

### follow.script

```lua
go.property("speed", 350) -- <1>

function init(self)
    msg.post(".", "acquire_input_focus") -- <2>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") or not action_id then -- <3>
		local current_pos = go.get_position() -- <4>
		local target_pos = vmath.vector3(action.x, action.y, 0) -- <5>
		local distance = vmath.length(target_pos - current_pos) -- <6>
		local duration = distance / self.speed -- <7>
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, target_pos, go.EASING_LINEAR, duration, 0) -- <8>
	end
end

--[[
1. The speed of the game object in pixels/second
2. Tell the engine that this game object ("." is shorthand for the current game object) should listen to input. Any input will be received in the `on_input()` function.
3. Check if we received mouse movement (no action id) or an input action named "touch" (touch or mouse click)
4. Get the current position of the game object.
5. Set the target position to the position of the mouse or touch.
6. Calculate the distance (length) between the current and target position.
7. Calculate the time it takes to travel the distance given the speed of the game object.
8. Animate the game object's ("." is shorthand for the current game object) position to `target_pos`.
--]]
```

<!-- movement/look_at -->

# Look at {#examples:movement:look_at}

This example shows how to rotate a game object to look at the mouse cursor

[Project files](https://github.com/defold/examples/tree/master/movement/look_at)

This example shows how to rotate a game object to look at the mouse cursor. It reads the mouse position in `on_input` and uses the mathematical function `math.atan2(x, y)` to calculate the angle between the ray to the point to look at and the positive x-axis. This angle is used to set the rotation of the game object to always look at the mouse position.

The example is suitable for the movement in two dimensions, for platformers or top-down games. For 3D objects, check out the [next example](/examples/movement/look_rotation/).

## Scripts

### look_at.script

```lua
function init(self)
	-- make sure the script will receive user input
	msg.post(".", "acquire_input_focus")
end

local function look_at(target_position)
	-- own positon
	local my_position = go.get_position()

	-- calculate the angle that this object has to rotate to look at the given point
	local angle = math.atan2(my_position.x - target_position.x, target_position.y - my_position.y)
	-- set rotation as a quaternion
	go.set_rotation(vmath.quat_rotation_z(angle))
end

function on_input(self, action_id, action)
	-- mouse/finger movement has action_id set to nil
	if not action_id then
		-- the position to look at (mouse/finger)
		local target_position = vmath.vector3(action.x, action.y, 0)
		-- rotate this object to look at the target position
		look_at(target_position)
	end
end
```

<!-- movement/look_rotation -->

# Look rotation {#examples:movement:look_rotation}

This example shows how to rotate a game object to look at the object in 3D space.

[Project files](https://github.com/defold/examples/tree/master/movement/look_rotation)

This example shows how to orient a game object to look at the target game object in 3D space. For this purpose, we created the function `quat_look_rotation` (also called `LookRotation` or `looking_at` in the industry). This function creates a rotation matrix from the forward and upwards vectors and then converts it to a quaternion. The function also handles the case where no upwards direction is specified, using the default (0, 1, 0) in that case.

Note: to properly apply the resulting rotation, you must remember that your game object must face backwards to the "z" axis, i.e. in Defold the "forward" direction is vector (0, 0, -1).

In this demo you can rotate the camera by holding down the mouse button. And also switch "targets" by pressing any key.

The models used in this example are from Kenney's [Prototype Kit](https://kenney.nl/assets/prototype-kit), licensed under CC0.

## Scripts

### look_rotation.script

```lua
--- Creates a rotation with the specified forward and upwards directions.
-- @param forward vector3 The forward direction.
-- @param upwards vector3|nil The upwards direction.
-- @return quat The rotation.
local function quat_look_rotation(forward, upwards)
	-- If no upwards direction is specified, use the default (0, 1, 0)
	upwards = upwards or vmath.vector3(0, 1, 0)

	-- No zero vectors
	if vmath.length_sqr(forward) < 0.0000000001 or vmath.length_sqr(upwards) < 0.0000000001 then
		return vmath.quat()
	end

	-- Create a rotation matrix from the forward and upwards vectors
	local matrix = vmath.matrix4_look_at(vmath.vector3(0), forward, upwards)

	-- Convert the matrix to a quaternion and return it
	return vmath.conj(vmath.quat_matrix4(matrix))
end

local function next_target(self)
	self.target = (self.target or 0) + 1
	if self.target > #self.targets then
		self.target = 1
	end

	local target_id = self.targets[self.target]

	local from = go.get_position("/sword")
	local to = go.get_position(target_id)

	self.target_rotation = quat_look_rotation(to - from)
end

function init(self)
	-- Acquire input focus to receive input events
	msg.post(".", "acquire_input_focus")

	-- List of target objects
	self.targets = {
		"/target1",
		"/target2",
		"/target3"
	}

	-- Set the initial target
	next_target(self)
end

function update(self, dt)
	-- If a target rotation is set, smoothly rotate the sword to face the target
	if self.target_rotation then
		-- Important: we must use vmath.slerp to animate quaternions
		local q = vmath.slerp(0.15, go.get_rotation("/sword"), self.target_rotation)
		go.set_rotation(q, "/sword")
	end
end

function on_input(self, action_id, action)
	-- If the left mouse button (or touch) is pressed, set the next target
	if action_id == hash("mouse_button_left") and action.pressed then
		next_target(self)
	end
end
```

<!-- movement/move_forward -->

# Move forward {#examples:movement:move_forward}

This example shows how to move a game object in the direction it is rotated/facing.

[Project files](https://github.com/defold/examples/tree/master/movement/move_forward)

## Scripts

### move_forward.script

```lua
go.property("acceleration", 100)
go.property("deceleration", 200)
go.property("max_speed", 400)
go.property("rotation_speed", 180)

-- unit vector pointing up
local UP = vmath.vector3(0, 1, 0)

function init(self)
	-- make sure the script will receive user input
	msg.post(".", "acquire_input_focus")

	-- movement input
	self.input = vmath.vector3()

	-- the current speed (pixels/second)
	self.speed = 0
end

function update(self, dt)
	-- accelerating?
	if self.input.y > 0 then
		-- increase speed
		self.speed = self.speed + self.acceleration * dt
		-- cap speed
		self.speed = math.min(self.speed, self.max_speed)
	else
		-- decrease speed when not accelerating
		self.speed = self.speed - self.deceleration * dt
		self.speed = math.max(self.speed, 0)
	end

	-- apply rotation based on self.input.x (left/right)
	local rot = go.get_rotation()
	-- amount to rotate (in radians)
	local rot_amount = math.rad(self.rotation_speed * self.input.x * dt)
	-- apply rotation as a quaternion created from a rotation of 'rot_amount' degrees around the z-axis
	rot = rot * vmath.quat_rotation_z(rot_amount)
	go.set_rotation(rot)

	-- move the game object
	local p = go.get_position()
	-- amount to move (pixels)
	local move_amount = UP * self.speed * dt
	-- apply rotation to movement vector to move game object in the direction of rotation
	p = p + vmath.rotate(rot, move_amount)
	go.set_position(p)

	-- reset input
	self.input = vmath.vector3()
end

function on_input(self, action_id, action)
	-- update direction of movement based on currently pressed keys
	if action_id == hash("key_up") then
		self.input.y = 1
	elseif action_id == hash("key_down") then
		self.input.y = -1
	elseif action_id == hash("key_left") then
		self.input.x = 1
	elseif action_id == hash("key_right") then
		self.input.x = -1
	end
end
```

<!-- movement/move_to -->

# Move to target {#examples:movement:move_to}

This example shows how to make a game object move to the position the user clicks.

[Project files](https://github.com/defold/examples/tree/master/movement/move_to)

## Scripts

### move_to.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.moving = false -- <2>
end

local function moved_to_position(self) -- <9>
	self.moving = false
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then -- <3>
		if not self.moving then -- <4>
			msg.post("#label", "disable") -- <5>
			self.moving = true -- <6>
			local pos = vmath.vector3(action.x, action.y, 0) -- <7>
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 0.5, 0, moved_to_position) -- <8>
		end
	end
end

--[[
1. Tell the engine that this game object ("." is shorthand for the current game object) should listen to input. Any input will be received in the `on_input()` function.
2. Store a flag in `self` (the current script component) to indicate if the game object is moving or not.
3. If we receive an input action named "touch" and it is pressed then run the following.
4. If the `moving` flag is not set.
5. Disable (don't show) the help text label.
6. Set the `moving` flag.
7. Create a new position called `pos` (of type `vector3`) where the user clicked.
8. Animate the game object's ("." is shorthand for the current game object) position to `pos`.
When the animation is done, call the function `moved_to_position()`.
9. The function `moved_to_position()` is called when the animation is done. It just resets the `moving` flag
so subsequent clicks will result in a new movement.
--]]
```

<!-- movement/movement_speed -->

# Movement speed {#examples:movement:movement_speed}

This example shows how to move a game object with accelerating speed.

[Project files](https://github.com/defold/examples/tree/master/movement/movement_speed)

## Scripts

### movement_speed.script

```lua
go.property("acceleration", 100)
go.property("deceleration", 200)
go.property("max_speed", 400)

function init(self)
	-- make sure the script will receive user input
	msg.post(".", "acquire_input_focus")

	-- movement input
	self.input = vmath.vector3()
	
	-- the current direction of movement
	self.direction = vmath.vector3()

	-- the current speed (pixels/second)
	self.speed = 0
end

function update(self, dt)
	-- is any key pressed?
	if self.input.x ~= 0 or self.input.y ~= 0 then
		-- set direction of travel from input
		self.direction = self.input
		-- increase speed
		self.speed = self.speed + self.acceleration * dt
		-- cap speed
		self.speed = math.min(self.speed, self.max_speed)
	else
		-- decrease speed when no key is pressed
		self.speed = self.speed - self.deceleration * dt
		self.speed = math.max(self.speed, 0)
	end

	-- move the game object
	local p = go.get_position()
	p = p + self.direction * self.speed * dt
	go.set_position(p)

	-- reset input
	self.input = vmath.vector3()
end

function on_input(self, action_id, action)
	-- update direction of movement based on currently pressed keys
	if action_id == hash("key_up") then
		self.input.y = 1
	elseif action_id == hash("key_down") then
		self.input.y = -1
	elseif action_id == hash("key_left") then
		self.input.x = -1
	elseif action_id == hash("key_right") then
		self.input.x = 1
	end
end
```

<!-- movement/simple_move -->

# Moving game object {#examples:movement:simple_move}

This example shows how to move a game object.

[Project files](https://github.com/defold/examples/tree/master/movement/simple_move)

## Scripts

### simple_move.script

```lua
function init(self)
	self.center = vmath.vector3(360, 360, 0) -- <1>
	self.radius = 160 -- <2>
	self.speed = 2 -- <3>
	self.t = 0 -- <4>
end

function update(self, dt)
	self.t = self.t + dt -- <5>
	local dx = math.sin(self.t * self.speed) * self.radius -- <6>
	local dy = math.cos(self.t * self.speed) * self.radius
	local pos = vmath.vector3() -- <7>
	pos.x = self.center.x + dx -- <8>
	pos.y = self.center.y + dy
	go.set_position(pos) -- <9>
end

--[[
1. Store the center of rotation in the script instance (available through `self`).
2. Store the movement radius.
3. Store the movement speed.
4. Store the elapsed time, in seconds.
5. Increase the elapsed time with `dt`, the delta time elapsed since last call to `update()`.
6. Compute offsets along the X and Y axis. We're using `sinus` and `cosinus` of the current time, scaled with `self.speed`, which will plot points along a circle with radius `self.radius`.
7. Create a new `vector3` which will contain the computed position.
8. Set the `x` and `y` components of the vector to the rotation center plus offsets along X and Y axis.
9. Set the computed position on the current game object.
--]]
```

<!-- particles/modifiers -->

# Modifiers {#examples:particles:modifiers}

This example shows particle effect modifiers. Modifiers are used to alter the path of emitted particles.

[Project files](https://github.com/defold/examples/tree/master/particles/modifiers)

Here two modifiers are added to the effect in addition to the emitter. It works as follows:

* The wide box emitter emits particles with a low speed.
* The *Acceleration* modifier pushes the particles causing them to continuously speed up.
* The *Vortex* modifier drags the particles into a vortex. Each particle's speed and direction is altered by the direction and magnitude of the vortex.

The particle system features more modifier types so make sure to check them out.

## Scripts

### modifiers.script

```lua
function init(self)
	particlefx.play("#particles") -- <1>
end

--[[
1. Start playing the particle effect in component "particles" in this game object.
--]]
```

<!-- particles/particlefx -->

# Particle effect {#examples:particles:particlefx}

This example shows a simple particle effect. The particlefx component has all the values at default, except the image and animation used.

[Project files](https://github.com/defold/examples/tree/master/particles/particlefx)

## Scripts

### particlefx.script

```lua
function init(self)
	particlefx.play("#particles") -- <1>
end

--[[
1. Start playing the particle effect in component "particles" in this game object.
--]]
```

<!-- particles/particlefx_emission_space -->

# Particle Effect Emission Space {#examples:particles:particlefx_emission_space}

This example demonstrates the difference between local and world particle emission spaces. Two UFO objects move up and down, showing how particles behave differently when emitted in emitter space versus world space.

[Project files](https://github.com/defold/examples/tree/master/particles/particlefx_emission_space)

This example shows how particle emission space affects particle behavior when the emitter object moves. The setup consists of two UFO objects with identical particle effects, but different emission space settings.

The example collection consists of 2 game objects that differ only in the particlefx used:

- particlefx on the left has Emission Space property set to "Emitter":

- particlefx on the right has Emission Space property set to "World":

Both game objects are animated up and down, so that you can see the difference between the emission space:

Particles emitted in emitter space are "moving" with the object, so their position is always respective to the emitter actual origin.

Particles emitted in world space have positions respective to the world coordinates.

Use this example to understand when to use local vs world emission space in your particle effects!

## Scripts

### particlefx.script

```lua
function init(self)
	--Start playing the particle effect in component "particles" in this game object:
	particlefx.play("#particles")

	-- Animate this object position on Y axis up and down forever
	go.animate(".", "position.y", go.PLAYBACK_LOOP_PINGPONG, 600, go.EASING_INOUTSINE, 4)
end
```

<!-- particles/confetti -->

# Particle effect example - confetti {#examples:particles:confetti}

This example shows a simple particle effect to imitate confetti.

[Project files](https://github.com/defold/examples/tree/master/particles/confetti)

In this example we create a confetti fireworks effect. It is usually used on final screens to congratulate the player on successful completion of a level or game.

The particlefx consists of 6 emitters. They are all the same, but with different images and RGB colors.

It has two modifiers:
 - Acceleration to make the particles fly downwards, i.e. to simulate gravity.
 - Drag to slow down the initial speed of the particles.

Changed properties (from default):
 - Blend Mode: Alpha for transparency blending
 - Max Particle Count: 8 to limit number of particles
 - Emitter Type: 2D Cone to set initial direction of the particles
 - Spawn Rate: 500 to spawn all particles at once
 - Emitter Size X: 100 +/- 20
 - Initial Speed: 1500 +/- 300 to make particles fly upwards

In addition, the curves for Life Scale, Life Alpha, Life Rotation properties have been adjusted to make the particles look like real confetti.

The main script `confetti.script` spawns the particlefx on startup or when any key is pressed or the mouse button is clicked. It also has a timer that spawns the particlefx in a loop with a 3 second delay.

## Scripts

### confetti.script

```lua
local function single_shot()
	particlefx.play("#particles") -- <1>
end

function init(self)
	single_shot()

	timer.delay(3, true, single_shot) -- <2>

	msg.post(".", "acquire_input_focus")
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_button_left") and action.pressed then -- <3>
		single_shot()
	end
end

--[[
1. Start playing the particle effect in component "particles" in this game object.
2. Setup timer to do a single shot of confetti every 3 seconds.
3. Play the effect when left mouse button (or touch) is pressed.
--]]
```

<!-- particles/fire_and_smoke -->

# Particle effect example - fire and smoke {#examples:particles:fire_and_smoke}

This example shows a simple particle effect for imitating fire and smoke.

[Project files](https://github.com/defold/examples/tree/master/particles/fire_and_smoke)

The particlefx consists of two emitters: for fire and smoke. Each of them has tweaked properties, images and modifiers. All combined creates a fire and smoke effect.

Fire emitter has a flame animation from sprites.atlas.
It is in front, because its Z position is 0.1, while smoke is at Z equal to 0.

It has two modifiers:
 - Acceleration with Magnitude 50 +/- 20
 - Radial with Magnitude: -50 +/- 20 positioned at Y = 150

Changed properties (from default):
 - Blend Mode: Alpha (for transparency blending)
 - Max Particle Count: 128
 - Emitter Type: Circle
 - Spawn Rate: 35 +/- 10
 - Emitter Size X: 100 +/- 20 (for circle emitters only Emitter Size X is taken into account, as radius)
 - Initial Speed: 30 +/- 20
 - Initial Size: 60 +/- 20
 - Initial Alpha: 0.8 +/- 0.2 (for a little transparency)
 - Initial Rotation: 180 (to make flame sprite upside down)

Additionally, the curves for Life Scale, Life Red, Life Green and Life Alpha properties were adjusted:

Smoke emitter has a smoke animation from sprites.atlas.

It has two modifiers:
 - Acceleration with Magnitude 20 +/- 10
 - Radial with Magnitude: -40 +/- 20 positioned at Y = 150

Changed properties (from default):
 - Position, Y: 60 (to emit a little bit above the fire)
 - Start Delay: 0.5 +/- 0.3 (to start a little bit after fire)
 - Blend Mode: Alpha (for transparency blending)
 - Max Particle Count: 32
 - Emitter Type: Circle
 - Spawn Rate: 4 +/- 2
 - Emitter Size X: 30 +/- 10  (for circle emitters only Emitter Size X is taken into account, as radius)
 - Particle Life Time: 5 +/- 0
 - Initial Speed: 10 +/- 10
 - Initial Size: 40 +/- 20
 - Initial Alpha: 0.5 +/- 0.3 (for a lot of transparency)
 - Initial Rotation: 0 +/- 90 (to make intial rotation of smoke sprite random)

 Additionally, the curves for Life Scale, Life Alpha and Life Rotation properties were adjusted:

## Scripts

### fire_and_smoke.script

```lua
function init(self)
	particlefx.play("#particles") -- <1>
end

--[[
1. Start playing the particle effect in component "particles" in this game object.
--]]
```

<!-- particles/fireworks -->

# Particle effect example - fireworks {#examples:particles:fireworks}

This example shows a fireworks effect made with particles.

[Project files](https://github.com/defold/examples/tree/master/particles/fireworks)

This effect consists of two particle effects: trail and bang. In this example there are three different colors, which could be easily changed in particle emitters settings.

The main script `fireworks.script` spawns the fireworks trail particlefx on startup or when any key is pressed or the mouse button is clicked. It also has a timer that spawns the particlefx in a loop with a 3 second delay.

To start effect:
- add factories for splat and trail particles;
- call "start_fireworks" method with parameters (time, start point, speed vector).

Images for particles are taken from Kenney Particle Pack.

## Scripts

### fireworks.script

```lua
local colors = {"red", "green", "blue"} -- list of existing fireworks colors
local instances = {} -- list of active fireworks instances

local _tension = 0.9 -- emulation of air tension. More value leads to faster deceleration
local _gravity = 980 -- gravity, measuring in mm/sq.s.

local function start_fireworks(trail_id, bang_id, start_pos, speed, time, gravity, tension)
	go.set_position(start_pos, trail_id)
	particlefx.play(trail_id)
	local m = {
		update = function(self, dt)
			if self.time > 0 then
				local prev_pos = vmath.vector3(self.start_pos)
				self.start_pos.x = self.start_pos.x + self.speed.x*dt
				self.start_pos.y = self.start_pos.y + self.speed.y*dt

				local triangle = vmath.vector3(prev_pos.x - start_pos.x, prev_pos.y - start_pos.y, 0)
				local angle = math.atan2(triangle.y, triangle.x)
				self.speed.x = self.speed.x - self.speed.x * self.tension*dt
				self.speed.y = self.speed.y - self.speed.y * self.tension*dt - self.gravity*dt

				go.set_position(self.start_pos, self.trail)
				go.set_rotation(vmath.quat_rotation_z(angle+math.pi/2), self.trail)
				if self.time > 0 then
					go.set_scale(self.time, self.trail)
				end

			elseif self.time <= 0 and not self.is_stopped then
				self.is_stopped = true
				particlefx.stop(self.trail, { clear = true })
				go.set_position(self.start_pos, self.bang)
				particlefx.play(self.bang)
			elseif self.time <= -1.5 and self.bang  then
				go.delete(self.bang)
				self.bang = nil
			end
			self.time = self.time - dt
		end,
		start_pos = start_pos,
		time = time,
		speed = speed,
		gravity = gravity or _gravity,
		tension = tension or _tension,
		trail = trail_id,
		bang = bang_id
	}

	return m
end

local function single_shot()
	if #instances > 5 then
		return
	end
	local color = colors[math.random(1, #colors)]
	local splat = factory.create("#"..color.."_splat_factory")
	local trail = factory.create("#"..color.."_trail_factory")

	local strength = 1000+math.random()*600 		-- scalar value of speed
	local angle = (-0.2+math.random()*0.4)*math.pi	-- angle beetween central vertical line and trail
	
	local pos = vmath.vector3(360-math.sin(angle)*350, 0, 0)
	local speed = vmath.vector3(strength*math.sin(angle), strength*math.cos(angle), 0)
	table.insert(instances, 
		start_fireworks(trail, splat, 
			pos, speed, 
			1.2+math.random()*0.5
		)
	)
end

function init(self)
	single_shot()

	timer.delay(3, true, single_shot) 

	msg.post(".", "acquire_input_focus")
end

function update(self, dt)
	for i, val in ipairs(instances) do
		if not val.bang then
			table.remove(instances, i)
		else
			val:update(dt)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_button_left") and action.pressed then
		single_shot()
	end
end
```

<!-- physics/dynamic -->

# Dynamic physics {#examples:physics:dynamic}

This example shows a simple setup with dynamic physics objects.

[Project files](https://github.com/defold/examples/tree/master/physics/dynamic)

The setup consists of three game objects. The *game.project* physics *GravityY* property is set to -500 to match the scale of the setup.

block1
: The rectangular stone block. Contains:
  - A *Sprite* component with the stone block image.
  - A *Collision object* component. The *Type* is set to `DYNAMIC`, *Friction* is set to 0 and *Restitution* to 1.0 (it will bounce forever). A box *Shape* matching the sprite image is added to the components.

block2
: The square stone block. Contains:
  - A *Sprite* component with the stone block image.
  - A *Collision object* component. Also has *Type* set to `DYNAMIC`, *Friction* set to 0 and *Restitution* to 1.0. A box *Shape* matching the sprite image is added to the components.

walls
: The outer walls. Contains:
  - A *Collision object* component. The *Type* is set to `STATIC`. 4 box *Shapes* are added to the component. These are placed just outside of the game view.

<!-- physics/hinge_joint -->

# Hinge joint physics {#examples:physics:hinge_joint}

This example shows a simple setup with a dynamic body physics object and two dynamic wheel physics object joined together with a joint of type "hinge". The hinge joint can simulate an axle or a pin on which other object is rotating in respect to the base. The example shows how to create, destroy and change properties of the joints.

[Project files](https://github.com/defold/examples/tree/master/physics/hinge_joint)

The setup consists of four game objects. The *game.project* physics *GravityY* property is set to -500 to match the scale of the setup.

body
: The square stone block. Contains:
  - A *Sprite* component with the stone block image.
  - A *Collision object* component. The *Type* is set to `DYNAMIC`. A box *Shape* matching the sprite image is added to the components.
  - A script that joines the wheel game objects to to the body and reacts to user input by changing the direction of the rotation of the hinge joints.
  - A label with an instruction to the user.

frontwheel
: The cirular metal wheel. Contains:
  - A *Sprite* component with the metal circle image.
  - A *Collision object* component. Also has *Type* set to `DYNAMIC`, *Friction* set to 0.9 and *Restitution* to 0.1. A box *Shape* matching the sprite image is added to the components.

backwheel
: The same as above.

walls
: The outer walls. Contains:
  - A *Collision object* component. The *Type* is set to `STATIC`. 4 box *Shapes* are added to the component. These are placed just outside of the game view.

## Scripts

### hinge_joint.script

```lua
local frontwheel = "frontwheel#collisionobject" -- <1>
local backwheel = "backwheel#collisionobject"
local body = "body#collisionobject"

local center_anchor = vmath.vector3(0, 0, 0)
local frontwheel_anchor = vmath.vector3(60, -60, 0)
local backwheel_anchor = vmath.vector3(-60, -60, 0)

local hinge_props = { enable_motor = true, enable_limit = false, max_motor_torque = 3000, motor_speed = 1 * 2 * math.pi}

function init(self)
	msg.post(".", "acquire_input_focus") -- <2>
	self.forward = true -- <3>
	physics.create_joint(physics.JOINT_TYPE_HINGE, frontwheel, "frontwheel", center_anchor, body, frontwheel_anchor, hinge_props) -- <4>
	physics.create_joint(physics.JOINT_TYPE_HINGE, backwheel, "backwheel", center_anchor, body, backwheel_anchor, hinge_props)
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then -- <5>
		self.forward = not self.forward -- <6>
		if self.forward then -- <7>
			hinge_props.motor_speed = 5 * 2 * math.pi -- <8>
		else  -- <9>
			hinge_props.motor_speed = -5 * 2 * math.pi -- <10>
		end
		physics.set_joint_properties(frontwheel, "frontwheel", hinge_props) -- <11>
		physics.set_joint_properties(backwheel, "backwheel", hinge_props)
	end
end

--[[
1. Store collision objects ids, vectors used for anchors and hinge properties used for creating joints in local variables.
2. Tell the engine that this object ("." is shorthand for the current game object) should listen to input. Any input will be received in the `on_input()` function.
3. Set a flag self.forward used to define the direction of the rotation of the joined wheels.
4. Create a joint of type "hinge" (a revolute joint, a pin or an axle) between a center of frontwheel collision object and an anchor ((-60,-60) from the center) on body collision object with provided properties. Do the same for the second wheel.
5. If we receive input (touch or mouse click) we switch the direction of rotation of the wheels.
6. Negate the current flag defining the direction.
7. If the direction flag is true, we are going forward.
8. Set the motor_speed property to 5 revolutions per second in clockwise direction.
9. If the direction flag is false, we are going backward.
10. Set the motor_speed property to 5 revolutions per second in counter-clockwise direction.
11. Set the new properties with changed speed for the joints.
--]]
```

<!-- physics/kinematic -->

# Kinematic physics {#examples:physics:kinematic}

This example shows a simple setup with a kinematic physics objects. The difference between dynamic objects, simulated by the physics engine, and kinematic objects, that are user controlled, is clearly seen here.

[Project files](https://github.com/defold/examples/tree/master/physics/kinematic)

The setup consists of three game objects. The *game.project* physics *GravityY* property is set to -500 to match the scale of the setup.

block
: The square stone block. Contains:
  - A *Sprite* component with the stone block image.
  - A *Collision object* component. The *Type* is set to `KINEMATIC`. A box *Shape* matching the sprite image is added to the components.
  - A script that moves the game object to where the user clicks.

block2
: The rectangular stone block. Contains:
  - A *Sprite* component with the stone block image.
  - A *Collision object* component. Also has *Type* set to `DYNAMIC`, *Friction* set to 0 and *Restitution* to 1.0. A box *Shape* matching the sprite image is added to the components.

walls
: The outer walls. Contains:
  - A *Collision object* component. The *Type* is set to `STATIC`. 4 box *Shapes* are added to the component. These are placed just outside of the game view.

## Scripts

### kinematic.script

```lua
function init(self)
    msg.post(".", "acquire_input_focus") -- <1>
    self.moving = false -- <2>
end

local function landed(self) -- <9>
    self.moving = false
end

function on_input(self, action_id, action)
    if action_id == hash("touch") and action.pressed then -- <3>
		if not self.moving then -- <4>
			msg.post("#label", "disable") -- <5>
			self.moving = true -- <6>
			pos = vmath.vector3(action.x, action.y, 0) -- <7>
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 0.5, 0, landed) -- <8>
		end
	end
end

--[[
1. Tell the engine that this object ("." is shorthand for the current game object) should listen to input. Any input will be received in the `on_input()` function.
2. Store a flag in `self` (the current script component) to indicate if the game object is moving or not.
3. If we receive an input action named "touch" and it is pressed then run the following.
4. If the `moving` flag is not set.
5. Disable (don't show) the help text label.
6. Set the `moving` flag.
7. Create a new position called `pos` (of type `vector3`) where the user clicked.
8. Animate the game object's ("." is shorthand for the current game object) position to `pos`.
   When the animation is done, call the function `landed()`.
9. The function `landed()` is called when the animation is done. It just resets the `moving` flag
   so subsequent clicks will result in a new movement.
--]]
```

<!-- physics/knockback -->

# Knockback {#examples:physics:knockback}

This example shows how to create a knockback effect when hit.

[Project files](https://github.com/defold/examples/tree/master/physics/knockback)

This example shows how to create a knockback effect when hit. The setup consists of three game objects; one for the player, one for the enemy and one for the bullet that is spawned using a factory (see example on how to spawn bullets).

player
: The red ship at the bottom. Contains:
  - A *Sprite* component with the spaceship image.
  - A *Factory* component to spawn bullet game objects
  - A script to handle spawning of bullets.

bullet
: The bullet fired by the player. Contains:
  - A *Sprite* component with a bullet image.
  - A *Collision object* component. *Type* is set to `KINEMATIC`. It has a sphere *Shape* matching image.

enemy
: The black ship at the top. Contains:
  - A *Sprite* component with the spaceship image.
  - A *Collision object* component. *Type* is set to `KINEMATIC`. It has a sphere *Shape* matching image.
  - A script to handle collisions with bullets.

## Scripts

### enemy.script

```lua
-- move game object back and forth from the current position to a target position
local function move()
	local pos = go.get_position()
	local to = vmath.vector3(pos.x, 300, 0)
	local distance = pos.y - to.y
	local speed = 40
	local duration = distance / speed
	go.animate(".", "position", go.PLAYBACK_LOOP_PINGPONG, to, go.EASING_INOUTQUAD, duration)
end

function init(self)
	move()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.other_group == hash("bullet") then
			-- delete the bullet
			go.delete(message.other_id)

			-- get the position of the game object
			local pos = go.get_position()
			-- set a pushback direction based on the collision normal
			local to = pos + message.normal * 30
			-- knockback animation, then continue moving
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_OUTQUAD, 0.1, 0, move)
		end
	end
end
```

<!-- physics/pendulum -->

# Pendulum physics {#examples:physics:pendulum}

This example shows a simple setup with a static pivot and two dynamic weights - physics objects joined together with a joint of type "fixed" and "spring". The fixed joint can simulate a rope and spring joint a spring. The example shows how to create the joints and change the gravity to affect the pendulums.

[Project files](https://github.com/defold/examples/tree/master/physics/pendulum)

The setup consists of four game objects. The *game.project* physics *GravityY* property is set to -500 to match the scale of the setup.

pivot
: The square stone block. Contains:
  - A *Sprite* component with the stone block image.
  - A *Collision object* component. The *Type* is set to `STATIC`. A box *Shape* matching the sprite image is added to the components.
  - A script that joines the weights game objects to to the pivot and reacts to user input by changing the direction of the physics gravity.
  - A label with an instruction to the user.

weight_fixed
: The cirular metal weight. Contains:
  - A *Sprite* component with the metal circle image.
  - A *Collision object* component. Also has *Type* set to `DYNAMIC`. A box *Shape* matching the sprite image is added to the component.

weight_spring
: The same as above.

walls
: The outer walls. Contains:
  - A *Collision object* component. The *Type* is set to `STATIC`. 4 box *Shapes* are added to the component. These are placed just outside of the game view.

## Scripts

### pendulum.script

```lua
local function draw_line(from, to)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(1,0,0,1) }) -- <1>
end

function init(self)
	msg.post(".", "acquire_input_focus") -- <2>
	self.gravity = physics.get_gravity() -- <3>
	self.pivot_pos = go.get_position()   -- <4>

	local center_anchor = vmath.vector3(0, 0, 0) -- <5>
	local pivot = "pivot#collisionobject"
	local weight_fixed = "weight_fixed#collisionobject"
	local weight_spring = "weight_spring#collisionobject"
	physics.create_joint(physics.JOINT_TYPE_FIXED, weight_fixed, "weight_fixed_joint", center_anchor, pivot, center_anchor, {max_length = 250}) -- <6>
	physics.create_joint(physics.JOINT_TYPE_SPRING, weight_spring, "weight_spring_joint", center_anchor, pivot, center_anchor, {length = 150, frequency = 1, damping = 0}) -- <7>
end

function update(self, dt)
	local weight_pos = go.get_position("/weight_fixed") -- <8>
	local weight1_pos = go.get_position("/weight_spring")
	draw_line(self.pivot_pos, weight_pos)  -- <9>
	draw_line(self.pivot_pos, weight1_pos)
end


function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then -- <10>
		if self.gravity.y ~= 0 then -- <11>
			self.gravity.y = 0
			self.gravity.x = 500
		else
			self.gravity.y = -500
			self.gravity.x = 0
		end
		physics.set_gravity(self.gravity) -- <12>
	end
end

--[[
1. Helper function to draw a line between two points.
2. Tell the engine that this object ("." is shorthand for the current game object) should listen to input. Any input will be received in the `on_input()` function.
3. Get current physics gravity vector and store it in self reference to change it later.
4. Get current position of the pivot and store it in self reference for drawing a line between the pivot and weights.
5. Store vector used for anchoring joints and collision objects ids in local variables for ease of use in below function.
6. Create a fixed joint between a first weight and the pivot
7. create a spring type joing between the second weight and the pivot.
8. Get updated positions of both weights.
9. Draw lines between the weights and the pivot.
10. If we receive input (touch or mouse click) we switch the direction of the gravity pull.
11. If the gravity is set to the bottom of the screen, set it so it pulls to the right, in other case, set it back to pull to the bottom.
12. Set the new gravity vector.
--]]
```

<!-- physics/raycast -->

# Raycast {#examples:physics:raycast}

This example shows how to use physics raycasts to detect collisions along a straight line from a start point to an end point.

[Project files](https://github.com/defold/examples/tree/master/physics/raycast)

The setup consists of two different kinds of game objects.

bee
: The bee. Contains:
  - A *Sprite* component with the bee image.
  - A script that performs raycasts from the game object position to the position of mouse/touch input.

stone
: The square stone block. Contains:
  - A *Sprite* component with the stone block image.
  - A *Collision object* component with a group set to `stone`.

## Scripts

### raycast.script

```lua
local function draw_line(from, to)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(1,0,0,1) })
end

function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	self.to = vmath.vector3() -- <2>
end

function update(self, dt)
	local from = go.get_position()
	local to = self.to
	local result = physics.raycast(from, to, { hash("stone") }) -- <4>
	if result then
		draw_line(from, result.position) -- <5>
	else
		draw_line(from, to) -- <6>
	end
end

function on_input(self, action_id, action)
	if not action_id or action_id == hash("touch") then -- <3>
		self.to.x = action.x
		self.to.y = action.y
	end
end

--[[
1. Tell the engine that this object ("." is shorthand for the current game object) should listen to input. Any input will be received in the `on_input()` function.
2. Store a position vector `to` in `self` (the current script component) to keep track of where to do a raycast.
3. If we receive input (touch or mouse movement) we update the position to where we should cast the ray.
4. Perform a raycast from the current game object position to where the mouse/touch is. The raycast is configured to only hit collision objects belonging to the `stone` group. The result will be stored in `result` or `nil` if no hit.
5. The raycast hit something! Draw a line (using the helper function at the top of the script) from the current game object position to where the raycast hit.
6. The raycast missed! Draw a line (using the helper function at the top of the script) from the current game object position to where the mouse/touch was.
--]]
```

<!-- physics/trigger -->

# Trigger {#examples:physics:trigger}

This example shows how a physics trigger is used to trigger an event. In this case the bunny sprite is disabled and enabled.

[Project files](https://github.com/defold/examples/tree/master/physics/trigger)

The setup consists of two game objects.

trigger
: The invisible trigger. Contains:
  - A *Collision object* component. The *Type* is set to `TRIGGER`. A box *Shape* is added to the components.

bunny
: The bunny. Contains:
  - A *Sprite* component with the bunny image.
  - A *Collision object* component. It has *Type* set to `DYNAMIC`. A sphere *Shape* matching the sprite image is added to the components.
  - A *Script* component that animates the bunny's position and reacts to physics messages when interacting with the trigger.

## Scripts

### bunny.script

```lua
function init(self)
	local pos = go.get_position() -- <1>
	go.animate(".", "position.x", go.PLAYBACK_LOOP_PINGPONG, pos.x + 600, go.EASING_INOUTSINE, 6)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then -- <2>
		if message.enter then -- <3>
			msg.post("#sprite", "disable") -- <4>
		else
			msg.post("#sprite", "enable") -- <5>
		end
	end
end

--[[
1. Get the current position, then animate the position's x component
   looping in a ping-pong manner against an offset of 600.
2. The physics engine has detected that this game object contains
   collision object components that have collided with a trigger.
3. The `message` data table contains a field `enter` that is set
   to `true` when the trigger event signals that the trigger shape
   was entered. On exiting the trigger, this field is `false`.
4. Disable the sprite when the trigger is entered
5. Enable the sprite again on exit.
--]]
```

<!-- render/camera -->

# Camera {#examples:render:camera}

This example shows how to use a camera component and have it follow a game object. Click to toggle between following the game object and staying stationary.

[Project files](https://github.com/defold/examples/tree/master/render/camera)

The setup consists of one `bee` game object that the camera can follow and one `camera` game object containing the camera component. The camera component will when active send view and projection updates to the render script.

bee
: The bee. Contains:
  - A *Sprite* component with the bee image.
  - A script that tells the camera whether it should follow the game object or not.

camera
: The camera. Contains:
  - A *Camera* component. The camera component has Orthographic Projection enabled.
  - A script that controls the camera component.

## Scripts

### bee.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus")
	go.animate(".", "position.x", go.PLAYBACK_LOOP_PINGPONG, 2000, go.EASING_INOUTQUAD, 10) -- <1>
	msg.post("camera", "follow") -- <2>
	self.follow = true -- <3>
end


function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then -- <4>
		self.follow = not self.follow
		if self.follow then
			msg.post("camera", "follow")
		else
			msg.post("camera", "unfollow")
		end
	end
end

--[[
1. Move this game object back and forth across the scene.
2. Send a message to the camera game object telling it to follow this game object.
3. Keep track of if the camera is following this game object or not.
4. Toggle between following and not following the game object when the left mouse button is clicked or the screen is touched.
--]]
```

### camera.script

```lua
function on_message(self, message_id, message, sender)
	if message_id == hash("follow") then -- <1>
		go.set_parent(".", sender) -- <2>
	elseif message_id == hash("unfollow") then -- <3>
		go.set_parent("camera", nil, true)
	end
end

--[[
1. Start following the game object that sent the `follow` message.
2. This is done by parenting the camera component to the game object that sent the message.
3. Stop following any game object. This is done removing the parent game object while maintaining the current world transform.
--]]
```

<!-- render/orbit_camera -->

# Orbit Camera {#examples:render:orbit_camera}

This example demonstrates how to create script to control a 3D camera with the mouse. Scroll wheel is used to zoom in and out.

[Project files](https://github.com/defold/examples/tree/master/render/orbit_camera)

In this example, we create a script to control a 3D camera using the mouse and mouse scroll wheel.

We added two objects to the collection: a camera (`/camera`) and an object (`/crate`) that we will explore. In the `camera` object, we added the `orbit_camera.script` - the script that controls the camera. The properties defined in the script are:
- `zoom`: the initial zoom level.
- `zoom_speed`: the speed of the zoom.
- `rotation_speed`: the speed of the rotation.
- `offset`: the offset of the camera from the origin. Use it to move the camera away from the origin.

During `init`, the script sets up the camera projection, acquires input focus, and establishes starting values for yaw, pitch, and zoom.

In the `update` loop, the script smoothly interpolates camera rotation and zoom (note: `vmath.lerp` is used and it doesn't depend on the delta time, so the camera will move at different speed on different devices), calculates the camera's rotation and position based on current yaw, pitch, and zoom values, and then updates the camera's position and rotation accordingly. This creates a fluid, responsive camera movement!

The function `on_input` handles user input to control the camera. As the user moves the mouse or touches the screen, the script adjusts the yaw and pitch values, allowing the camera to rotate around its focal point. Additionally, it responds to mouse wheel input, adjusting the zoom level to move the camera closer to or further from the center point.

The model used in this example is from Kenney's [Prototype Pack](https://kenney.nl/assets/prototype-kit), licensed under CC0.

## Scripts

### orbit_camera.script

```lua
-- The initial zoom level
go.property("zoom", 3)
-- The speed of the zoom
go.property("zoom_speed", 0.1)
-- The speed of the rotation
go.property("rotation_speed", 0.5)
-- The offset of the camera from the origin
go.property("offset", vmath.vector3(0, 0, 0))

function init(self)
	-- Acquire input focus to receive input events
	msg.post(".", "acquire_input_focus")

	-- Initialize start values
	self.yaw = go.get(".", "euler.y")
	self.pitch = go.get(".", "euler.x")
	self.zoom_offset = 0
	self.current_yaw = self.yaw
	self.current_pitch = self.pitch
	self.current_zoom = self.zoom_offset
end

function update(self, dt)
	-- Animate camera rotation and zoom
	self.current_yaw = vmath.lerp(0.15, self.current_yaw, self.yaw)
	self.current_pitch = vmath.lerp(0.15, self.current_pitch, self.pitch)
	self.current_zoom = vmath.lerp(0.15, self.current_zoom, self.zoom_offset)

	-- Calculate rotation and position
	local camera_yaw = vmath.quat_rotation_y(math.rad(self.current_yaw))
	local camera_pitch = vmath.quat_rotation_x(math.rad(self.current_pitch))
	local camera_rotation = camera_yaw * camera_pitch
	local camera_position = self.offset + vmath.rotate(camera_rotation, vmath.vector3(0, 0, self.zoom + self.current_zoom))

	-- Set camera position and rotation
	go.set_position(camera_position)
	go.set_rotation(camera_rotation)
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and not action.pressed then
		self.yaw   = self.yaw   - action.dx * self.rotation_speed
		self.pitch = self.pitch + action.dy * self.rotation_speed
	elseif action_id == hash("mouse_wheel_up") then
		self.zoom_offset = self.zoom_offset - self.zoom * self.zoom_speed
	elseif action_id == hash("mouse_wheel_down") then
		self.zoom_offset = self.zoom_offset + self.zoom * self.zoom_speed
	end
end
```

<!-- render/post_processing -->

# Post-processing {#examples:render:post_processing}

This example shows how to apply a post-processing effect by drawing to a render target and then to a fullscreen quad using a post processing shader.

[Project files](https://github.com/defold/examples/tree/master/render/post_processing)

The basic principle of a full screen post processing effect is to first draw the entire game to a render target, then draw this render target to a full screen quad using a post processing shader to apply some kind of effect. This example shows a color invert effect and a CRT scanline effect.

The setup in this example consists of a custom render script and a game object containing a model component with a fullscreen quad (ie rectangle).

The model uses a material with a render predicate/tag named `postprocess`. The material uses a basic shader program in `invert.fp` to invert the color of anything drawn with the material.

The render script is a copy of the default render script with added code to create a fullscreen render target. The render target has a color and depth buffer, and it will be resized if the screen resolution changes:
```lua
local function create_postprocess_rt(self, width, height)
    local color_params = {
        format = graphics.TEXTURE_FORMAT_RGBA,
        width = width,
        height = height,
        min_filter = render.FILTER_LINEAR,
        mag_filter = render.FILTER_LINEAR,
        u_wrap = render.WRAP_CLAMP_TO_EDGE,
        v_wrap = render.WRAP_CLAMP_TO_EDGE
    }
    local depth_params = {
        format = graphics.TEXTURE_FORMAT_DEPTH,
        width = width,
        height = height,
    }
    self.postprocess_rt =  render.render_target("postprocess_rt", { [render.BUFFER_COLOR_BIT] = color_params, [render.BUFFER_DEPTH_BIT] = depth_params } )
    self.postprocess_rt_width = width
    self.postprocess_rt_height = height
end

local function update_postprocess_rt(self)
    local w = render.get_window_width()
    local h = render.get_window_height()

    -- keep render target if size is the same
    if self.postprocess_rt_width == w and self.postprocess_rt_height == h then
        return
    end

    render.delete_render_target(self.postprocess_rt)
    create_postprocess_rt(self, w, h)
end

function init(self)
    -- create the postprocess predicate and all of the default predicates
    self.predicates = create_predicates("postprocess", "tile", "gui", "particle", "model", "debug_text")

    create_postprocess_rt(self, render.get_window_width(), render.get_window_height())
end

function update(self)
    update_postprocess_rt(self)
end
```

The render script is additionally modified so that all content is drawn to the render target instead of directly to the screen. In a separate step at the end, the render target is used as a texture and drawn to the fullscreen quad with the `postprocess` predicate using the post processing shader assigned to the model quad:

```lua
function update(self)
    update_postprocess_rt(self)

    -- enable postprecssing render target
    -- subsequent draw operations will be done to the render target
    --
    render.set_render_target(self.postprocess_rt)

    -- note: some render code removed from this snippet to make it readable
    render.draw(predicates.model, draw_options_world)
    render.draw(predicates.tile, draw_options_world)
    render.draw(predicates.particle, draw_options_world)
    render.draw(predicates.gui, camera_gui.options)
    render.draw(predicates.debug_text, camera_gui.options)

    -- revert to the default render target
    --
    render.set_render_target(render.RENDER_TARGET_DEFAULT)

    -- render post processing render target to quad with predicate 'postprocess'
    --
    render.set_view(vmath.matrix4())
    render.set_projection(vmath.matrix4())
    render.enable_texture(0, self.postprocess_rt, render.BUFFER_COLOR_BIT)
    render.draw(predicates.postprocess)
    render.disable_texture(0)
end
```

Additionally the example shows in `postprocess.script` how to change material using material resource properties at runtime.

## Scripts

### postprocess.script

```lua
go.property("invert", resource.material("/example/materials/invert.material"))
go.property("passthrough", resource.material("/example/materials/passthrough.material"))
go.property("scanlines", resource.material("/example/materials/scanlines.material"))

function init(self)
	msg.post(".", "acquire_input_focus")
	go.set("#quad", "material", self.invert)
end

function on_input(self, action_id, action)
	if action_id == hash("key_1") then
		go.set("#quad", "material", self.invert)
	elseif action_id == hash("key_2") then
		go.set("#quad", "material", self.scanlines)
		local w, h = window.get_size()
		go.set("#quad", "resolution", vmath.vector4(w, h, 0, 0))
	elseif action_id == hash("key_3") then
		go.set("#quad", "material", self.passthrough)
	end
end
```

### invert.fp

```glsl
#version 140

in mediump vec2 var_texcoord0;

out vec4 out_fragColor;

uniform mediump sampler2D tex0;

void main()
{
    vec4 color = texture(tex0, var_texcoord0.xy);
    color.r = 1.0 - color.r;
    color.g = 1.0 - color.g;
    color.b = 1.0 - color.b;
        
    out_fragColor = vec4(color.rgb,1.0);
}
```

### invert.vp

```glsl
#version 140

in highp vec4 position;
in mediump vec2 texcoord0;

out mediump vec2 var_texcoord0;

uniform vs_uniforms
{
    highp mat4 view_proj;
};

void main()
{
    gl_Position = view_proj * vec4(position.xyz, 1.0);
    var_texcoord0 = texcoord0;
}
```

<!-- render/screen_to_world -->

# Screen to World {#examples:render:screen_to_world}

This example shows how to convert from screen to world coordinates while using a camera.

[Project files](https://github.com/defold/examples/tree/master/render/screen_to_world)

The `bee.script` uses the `camera.screen_to_world()` function to convert from screen space coordinates to world coordinates using the view and projection of a camera component.

## Scripts

### bee.script

```lua
function init(self)
	-- send input events to this script
	msg.post(".", "acquire_input_focus")
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		-- convert mouse/touch screen position to world position
		local screen = vmath.vector3(action.screen_x, action.screen_y, 0)
		local world = camera.screen_to_world(screen, "#camera")

		-- alternative using camera.screen_xy_to_world(x, y, camera)
		-- local world = camera.screen_xy_to_world(action.screen_x, action.screen_y, v)

		-- animate bee to new world position
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, world, go.EASING_LINEAR, 0.5, 0)
	end
end
```

<!-- render/world_to_screen -->

# World to Screen {#examples:render:world_to_screen}

This example demonstrates how to convert 3D world coordinates to 2D screen coordinates using camera transformations.

[Project files](https://github.com/defold/examples/tree/master/render/world_to_screen)

This example shows how to convert world positions to screen coordinates for UI positioning. It features:

* Use of the built-in `camera.world_to_screen()` API to transform 3D world positions to 2D screen coordinates.
* A reference Lua `world_to_screen()` implementation (below) kept as an example to help understand how the conversion works internally.
* A ghost character that rotates around a crypt in 3D space while floating up and down.
* A player name label in the GUI that follows the character's world position by converting it to screen coordinates.
* Demonstrates practical use of world-to-screen conversion for positioning UI elements relative to 3D objects.

Note: The reference Lua version does not preserve depth information and always returns `z = 0` to keep the code simpler.
```lua
--- Converts a world position to screen coordinates.
-- This function transforms a 3D world position to 2D screen coordinates using the camera's
-- view and projection matrices. The resulting coordinates are in screen space where (0,0)
-- is the bottom-left corner of the screen.
--
-- @param world_position vector3 The world position to convert.
-- @param camera_url url|string The camera component URL to use for the transformation.
-- @return number screen_x The X coordinate in screen space.
-- @return number screen_y The Y coordinate in screen space.
-- @return number screen_z Always returns 0 (depth information is not preserved).
local function world_to_screen(world_position, camera_url)
    local proj = camera.get_projection(camera_url)
    local view = camera.get_view(camera_url)

    local view_proj = proj * view
    local scr_coord = view_proj * vmath.vector4(world_position.x, world_position.y, world_position.z, 1)
    local w, h = window.get_size()
    scr_coord.x = (scr_coord.x / scr_coord.w + 1) * 0.5 * w
    scr_coord.y = (scr_coord.y / scr_coord.w + 1) * 0.5 * h

    return vmath.vector3(scr_coord.x, scr_coord.y, 0)
end
```

## Scripts

### player.script

```lua
go.property("camera_url", msg.url("/camera#camera")) -- URL of the camera component
go.property("hud_url", msg.url("/ui#hud"))
go.property("angle", -45) -- we use this property to animate the rotation of the player around the center of the scene

function init(self)
	-- Get the IDs of the player view and UI objects
	self.player_view_id = go.get_id("player_view")
	self.player_ui_id = go.get_id("player_ui")

	-- Animate vertical position of the body
	local new_pos_y = go.get(self.player_view_id, "position.y") + 0.2
	go.animate(self.player_view_id, "position.y", go.PLAYBACK_LOOP_PINGPONG, new_pos_y, go.EASING_INOUTSINE, 2)

	-- Get the base position
	self.base_pos = go.get_position()

	-- Animate the angle to rotate the player around the center of the scene
	go.animate("#", "angle", go.PLAYBACK_LOOP_FORWARD, -3600 + self.angle, go.EASING_LINEAR, 200)
end

function final(self)
end

function update(self, dt)
	-- Update the position of the player based on the angle and the base position
	local radius = self.base_pos.z
	go.set_position(vmath.vector3(radius * math.sin(math.rad(self.angle)), self.base_pos.y, radius * math.cos(math.rad(self.angle))))
	-- Update the rotation of the player based on the angle
	go.set(".", "euler.y", self.angle + 90)

	-- Update the world transform of the player UI object and convert the world position to screen coordinates
	go.update_world_transform(self.player_ui_id)
	local world_pos = go.get_world_position(self.player_ui_id)
	local screen_pos = camera.world_to_screen(world_pos, self.camera_url)
	-- Send the screen position to the HUD script
	msg.post(self.hud_url, "update_data", { screen_position = screen_pos })
end
```

<!-- resource/create_atlas -->

# Create atlas {#examples:resource:create_atlas}

This example shows how to create an atlas with two images and use it on a sprite and in a gui

[Project files](https://github.com/defold/examples/tree/master/resource/create_atlas)

The example creates a texture and an atlas with two images and uses the two images on a sprite and a gui box node.

## Scripts

### create_atlas.script

```lua
local function create_texture(width, height)
	-- create a new rgba texture
	local create_texture_params = {
		width  = width,
		height = height,
		type   = resource.TEXTURE_TYPE_2D,
		format = resource.TEXTURE_FORMAT_RGBA,
	}
	local my_texture_id = resource.create_texture("/my_custom_texture.texturec", create_texture_params)

	-- create a buffer with pixel data
	local buf = buffer.create(width * height, { { name=hash("rgba"), type=buffer.VALUE_TYPE_UINT8, count=4 } } )
	local stream = buffer.get_stream(buf, hash("rgba"))

	local half_width = width / 2
	for y=1, height do
		for x=1, width do
			local index = (y-1) * width * 4 + (x-1) * 4 + 1
			stream[index + 0] = x > half_width and 0xFF or 0x00
			stream[index + 1] = x > half_width and 0x00 or 0xFF
			stream[index + 2] = x > half_width and 0x00 or 0x00
			stream[index + 3] = 0xFF
		end
	end

	-- set the pixels on the texture
	local set_texture_params = { width=width, height=height, x=0, y=0, type=resource.TEXTURE_TYPE_2D, format=resource.TEXTURE_FORMAT_RGBA, num_mip_maps=1 }
	resource.set_texture(my_texture_id, set_texture_params, buf)
	
	return my_texture_id
end

local function create_atlas(texture_id, width, height)
	local params = {
		texture = texture_id,
		animations = {
			{
				id          = "my_animation_left",
				width       = width / 2,
				height      = height,
				frame_start = 1,
				frame_end   = 2,
			},
			{
				id          = "my_animation_right",
				width       = width / 2,
				height      = height,
				frame_start = 2,
				frame_end   = 3,
			}
		},
		geometries = {
			{
				width = width / 2,
				height = height,
				pivot_x = 0.5,
				pivot_y = 0.5,
				vertices  = {
					0,         height,
					0,         0,
					width / 2, 0,
					width / 2, height
				},
				uvs = {
					0,         height,
					0,         0,
					width / 2, 0,
					width / 2, height
				},
				indices = {0,1,2,0,2,3}
			},
			{
				width = width / 2,
				height = height,
				pivot_x = 0.5,
				pivot_y = 0.5,
				vertices  = {
					0,         height,
					0,         0,
					width / 2, 0,
					width / 2, height
				},
				uvs = {
					width / 2,  height,
					width / 2,  0,
					width,      0,
					width,      height
				},
				indices = {0,1,2,0,2,3}
			}
		}
	}
	local my_atlas_id = resource.create_atlas("/my_atlas.texturesetc", params)
	return my_atlas_id
end

function init(self)
	local width = 128
	local height = 128
	local my_texture_id = create_texture(width, height)
	local my_atlas_id = create_atlas(my_texture_id, width, height)

	-- set the new atlas on the sprite and show one image
	go.set("#sprite", "image", my_atlas_id)
	sprite.play_flipbook("#sprite", "my_animation_left")

	-- set the new atlas on the gui component and use on a node from the gui script
	go.set("gui#gui", "textures", my_atlas_id, { key = "my_atlas" })
	msg.post("gui#gui", "use_atlas", { texture = "my_atlas", animation = "my_animation_right" })
end
```

### create_atlas.gui_script

```lua
function on_message(self, message_id, message, sender)
	if message_id == hash("use_atlas") then
		local box = gui.get_node("box")
		gui.set_texture(box, message.texture)
		gui.play_flipbook(box, message.animation)
	end
end
```

<!-- resource/modify_atlas -->

# Modify atlas {#examples:resource:modify_atlas}

This example shows how to replace an image in an atlas

[Project files](https://github.com/defold/examples/tree/master/resource/modify_atlas)

The example loads an image bundled as a custom resource (bundled in the game archive) and uses it to replace the first image of an atlas. See code comments for implementation details.

## Scripts

### modify_atlas.script

```lua
-- load image from custom resources
-- read pixels and write them to a buffer
local function create_buffer_from_image(filename)
	local png = assert(sys.load_resource(filename))
	local loaded_image = image.load(png)
	local width = loaded_image.width
	local height = loaded_image.height
	local pixels = loaded_image.buffer

	local buffer_declaration = {
		{
			name = hash("rgba"),
			type = buffer.VALUE_TYPE_UINT8,
			count = 4
		}
	}
	local pixel_buffer = buffer.create(width * height, buffer_declaration)
	local pixel_stream = buffer.get_stream(pixel_buffer, hash("rgba"))
	for y = 1, height do
		for x = 1, width do
			-- flip image
			local pixels_index = ((height - y) * width * 4) + ((x - 1) * 4) + 1
			local r = pixels:byte(pixels_index + 0)
			local g = pixels:byte(pixels_index + 1)
			local b = pixels:byte(pixels_index + 2)
			local a = pixels:byte(pixels_index + 3)

			-- write to buffer stream
			local stream_index = ((y - 1) * width * 4) + ((x - 1) * 4) + 1
			pixel_stream[stream_index + 0] = r
			pixel_stream[stream_index + 1] = g
			pixel_stream[stream_index + 2] = b
			pixel_stream[stream_index + 3] = a
		end
	end

	return pixel_buffer, width, height
end

local function replace_atlas_image()
	-- get table with information about an atlas
	local atlas = resource.get_atlas("/example/modify_atlas.a.texturesetc")
	-- get table with information about the textured used by the atlas
	local texture = resource.get_texture_info(atlas.texture)
	pprint(atlas)
	pprint(texture)

	-- load an image as a Defold buffer
	local pixel_buffer, width, height = create_buffer_from_image("/example/resources/shipYellow_manned.png")

	-- get the UV coordinates of the first image in the atlas
	local first_uvs = atlas.geometries[1].uvs

	-- this offset should not be necessary but it seems like there is an issue with the
	-- UVs in Defold 1.5.0
	local x = first_uvs[1] - 0
	local y = first_uvs[2] - 6
	print(x, y)
	print(width, height)

	-- create a table with texture update information
	-- we want to update only a sub region of the atlas starting at a
	-- certain position and with a certain size
	local texture_info = {
		type = resource.TEXTURE_TYPE_2D,
		width = width,
		height = height,
		format = resource.TEXTURE_FORMAT_RGBA,
		x = x,
		y = y,
		compression_type = resource.COMPRESSION_TYPE_DEFAULT,
		num_mip_maps = texture.mipmaps,
	}
	-- update the atlas texture with the pixels from the provided buffer
	resource.set_texture(atlas.texture, texture_info, pixel_buffer)
end


function init(self)
	msg.post(".", "acquire_input_focus")
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_button_left") and action.pressed then
		replace_atlas_image()
	end
end
```

<!-- sound/fade_in_out -->

# Fade In-Out {#examples:sound:fade_in_out}

This example shows how to make Fade-In and fade Fade-Out music.

[Project files](https://github.com/defold/examples/tree/master/sound/fade_in_out)

## Scripts

### fade_in_out.script

```lua
local TIME = 2 -- <1>
local DELAY = 1 -- <2>

function init(self)
    sound.play("#music", { gain = 1.0 }) -- <3>
    msg.post("#", "fade_in_out") -- <4>
end

function on_message(self, message_id, message, sender)
    if message_id == hash("fade_in_out") then
        go.animate("#music", "gain", go.PLAYBACK_LOOP_PINGPONG, 0, go.EASING_LINEAR, TIME, DELAY) -- <5>
    end
end


--[[
1. Create TIME constant - duration of the fade-in and fade-out effect.
2. Create DELAY constant - pause before the start of the fade-in and fade-out effect.
3. Tell the component "#music" to start playing its sound with a gain of 1.0
4. Send a "fade_in_out" message to the script telling it to start fading the music in and out
5. Animate the "gain" property of the sound component back and forth between 0 and the current value (1.0)
--]]
```

<!-- sound/get_set_sound -->

# Get and set sound {#examples:sound:get_set_sound}

This example shows how to change which sound a sound component plays

[Project files](https://github.com/defold/examples/tree/master/sound/get_set_sound)

This example shows how to change which sound a sound component plays. Additional sounds are stored as individual .ogg files in the `sounds` folder and included in the build as [Custom Resources](https://defold.com/manuals/file-access/#custom-resources):

The example consists of a single collection with a game object containing a Sound component, a Sprite component for visuals and a Script to control the logic:

Sound effects and space ship by [Kenney](https://www.kenney.nl)

## Scripts

### get_set_sound.script

```lua
function init(self)
    msg.post(".", "acquire_input_focus")

    -- animate the spaceship up and down "for dramatic effect"
    go.animate(".", "position.y", go.PLAYBACK_LOOP_PINGPONG, go.get_position().y + 20, go.EASING_INOUTQUAD, 1)

    -- play the engine sound
    sound.play("#enginesound")
end


function on_input(self, action_id, action)
    if action_id == hash("mouse_button_left") and action.pressed then
        -- a list of sounds to chose between
        local sounds = {
            "/sounds/spaceEngine_001.ogg",
            "/sounds/spaceEngine_002.ogg",
            "/sounds/spaceEngine_003.ogg",
        }
        -- pick one at random
        local random_sound = sounds[math.random(1, #sounds)]

        -- load the new sound
        -- stop the currently playing sound
        -- set the sound on the sound component
        -- play it again
        local engine3 = sys.load_resource(random_sound)
        sound.stop("#enginesound")
        resource.set_sound(go.get("#enginesound", "sound"), engine3)
        sound.play("#enginesound")
    end
end
```

<!-- sound/music -->

# Music {#examples:sound:music}

This example shows how to play a piece of music, stored as an .OGG file, with a sound component. The sound component is set to "looping" causing the music to never, ever stop.

[Project files](https://github.com/defold/examples/tree/master/sound/music)

## Scripts

### music.script

```lua
function init(self)
    sound.play("#music", { gain = 1.0, pan = 0 }) -- <1>
end

--[[
1. Tell the component "#music" to start playing its sound. The sound will be played with gain 1.0 (max volume) and pan 0.0 (equal left-right channel)
--]]
```

<!-- sound/panning -->

# Panning {#examples:sound:panning}

This example demonstrates how to pan a sound effect according to a GO's(game object) position on the screen.

[Project files](https://github.com/defold/examples/tree/master/sound/panning)

Overview : A coin bounces around the screen and on collision detection we get the coins x position then normalize that value for use in the sound components pan property. As the API states "The pan on the sound-component. The valid range is from -1.0 to 1.0, representing -45 degrees left, to +45 degrees right." we can use this information along with our x value from our coin object and normalize it into the correct range.

The setup consists of a coin game object, three stone objects and walls for collision.

Coin
: contains:
  - A *Sound* component.
  - A *Collision* component. With *Type* set to `DYNAMIC` and a Sphere *Shape*.
  - A script used to set initial coin movement then set pan value and play a sound on collision.
  - A sprite component with default animation set as coin

Stones
: contains:
  - A *Collision* component set to `STATIC` and 1 box *Shape* to match the sprite image.

Walls
: contains:
  - A *Collision* component set to `STATIC` and 4 box *Shapes* that make up the walls along the bounds of the game screen.

## Scripts

### pan.script

```lua
local position_min = 0  -- <1>
local position_max = sys.get_config_int("display.width")  -- <2>

local function normalize_position(x_position)  -- <3>
	local average = (position_min + position_max) / 2
	local range = (position_max - position_min) / 1.8
	local result = (x_position - average) / range
	return result
end

function on_message(self, message_id, message, sender)  -- <4>
	if message_id == hash("collision_response") then
		local coin_pos = normalize_position(go.get_position().x)
		sound.play("#coin", { gain = 0.6, pan = coin_pos } )
	end
end

--[[

1. - Local variable to represent the minimum x position value. 

2. - Local variable to represent the maximum x position value. sys.get_config_int("display.width") to get 
	screen width used for maximum x position value.

3. - This function uses the screen x position min & max local variables that is set at the top
	of the script to get an average and range then pass in the coin objects x position into 
	result to get a normalized value and the function returns that value. note: in range if we 
	divide by 2.0 we would get range -1.0 to 1.0 full 45 degree pan at min/max positions, instead 
	use 1.8 to get around a 40 deg pan that way we always get a little bit of sound in both 
	left and right channel outputs no matter the min/max position.

4. - When a collision_response is received we pass in the coin objects x position into the 
	normalize_position function and set the results to the local variable coin_pos. Then play 
	a sound and pass in coin_pos into the sounds pan property.

Now we have simple sound localization using the pan property. If you close your eyes, you should
be able to gauge which direction the collisions are occurring.(as long as you are using stereo sound) 

--]]
```

<!-- sprite/bunnymark -->

# Bunnymark {#examples:sprite:bunnymark}

This is a performance test for sprites

[Project files](https://github.com/defold/examples/tree/master/sprite/bunnymark)

The example spawns game objects and animates them using go.animate(). An alternative bunnymark test with more options can be found [here](https://github.com/britzl/defold-bunnymark).

## Scripts

### bunnymark.script

```lua
local BUNNY_IMAGES = {
	hash("rabbitv3_batman"),
	hash("rabbitv3_bb8"),
	hash("rabbitv3"),
	hash("rabbitv3_ash"),
	hash("rabbitv3_frankenstein"),
	hash("rabbitv3_neo"),
	hash("rabbitv3_sonic"),
	hash("rabbitv3_spidey"),
	hash("rabbitv3_stormtrooper"),
	hash("rabbitv3_superman"),
	hash("rabbitv3_tron"),
	hash("rabbitv3_wolverine"),
}

local DISPLAY_WIDTH = sys.get_config_int("display.width")
local DISPLAY_HEIGHT = sys.get_config_int("display.height")

local SPAWN_COUNT = 1000

local function spawn(self, amount)
	for i=1,amount do
		local bunny = factory.create("#factory")
		if bunny then
			local img = BUNNY_IMAGES[math.random(1, #BUNNY_IMAGES)]
			sprite.play_flipbook(msg.url(nil, bunny, "sprite"), img)
			go.set_position(vmath.vector3(math.random(DISPLAY_WIDTH), DISPLAY_HEIGHT, 0), bunny)
			go.animate(bunny, "position.y", go.PLAYBACK_LOOP_PINGPONG, 40, go.EASING_INQUAD, 2, math.random())
			self.bunnies = self.bunnies + 1
		else
			print("Unable to create more bunnies")
			break
		end
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.frames = {}
	self.bunnies = 0
	spawn(self, SPAWN_COUNT)
end

function update(self, dt)
	self.frames[#self.frames + 1] = socket.gettime()
	local fps = 0
	if #self.frames == 61 then
		table.remove(self.frames, 1)
		fps = 1 / ((self.frames[#self.frames] - self.frames[1]) / (#self.frames - 1))
	end
	label.set_text("#label", ("Bunnies: %d FPS: %.2f. Click to add more"):format(self.bunnies, fps))	
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released and action.y < 1030 then
		spawn(self, SPAWN_COUNT)
	end
end
```

<!-- sprite/changeimage -->

# Change sprite image {#examples:sprite:changeimage}

This example shows how to change the image of a sprite

[Project files](https://github.com/defold/examples/tree/master/sprite/changeimage)

The example shows a game object with a sprite and a script with three script properties to reference different tilesource images. The script lets the user change which image to use on the sprite.

It is also possible to use a script property to reference an atlas instead of a tilesource:
```lua
go.property("hero", resource.atlas("/assets/hero.atlas"))

function init(self)
	go.set("#sprite", "image", self.hero)
end
```

## Scripts

### changeimage.script

```lua
-- create script properties with references to three different tile sources
go.property("robot", resource.tile_source("/assets/robot.tilesource"))
go.property("zombie", resource.tile_source("/assets/zombie.tilesource"))
go.property("adventurer", resource.tile_source("/assets/adventurer.tilesource"))

local function update_tilesource(image_id)
	-- set the sprite image property to the specified tilesource
	go.set("#sprite", "image", image_id)
	-- play the run animation
	sprite.play_flipbook("#sprite", "run")
end

function init(self)
	msg.post(".", "acquire_input_focus")
	update_tilesource(self.robot)
end

-- change sprite image when key 1, 2 and 3 are pressed
function on_input(self, action_id, action)
	if action.pressed then
		if action_id == hash("key_1") then
			update_tilesource(self.robot)
		elseif action_id == hash("key_2") then
			update_tilesource(self.zombie)
		elseif action_id == hash("key_3") then
			update_tilesource(self.adventurer)
		end
	end
end
```

<!-- sprite/flip -->

# Flip {#examples:sprite:flip}

This example demonstrates flipping a sprite animation vertically and horizontally.

[Project files](https://github.com/defold/examples/tree/master/sprite/flip)

Overview :  [sprite.set_hflip](https://defold.com/ref/beta/sprite/#sprite.set_hflip:url-flip) & [sprite.set_vflip](https://defold.com/ref/beta/sprite/#sprite.set_vflip:url-flip) uses a boolean to set if a sprite animation should be flipped.

The setup consists of 2 bee game object's, another game object for text labels and a single script.

2 Game Object's
: containing:
  - A sprite with default animation set to bee

1 Game object
: contains:
 - A script
 - 2 text labels

Script
: use:
  - Sets sprite flip and go.animation for bee game objects.

## Scripts

### flip.script

```lua
local horizontal = "bee1" -- < 1 >
local vertical = "bee2"

local function bee_flip(go_id) -- < 2 >
	if go_id == horizontal then
		local bee_position = go.get_position(horizontal)
		if bee_position.x == 400 then
			sprite.set_hflip("bee1#sprite", false)
			go.animate(horizontal,"position.x",go.PLAYBACK_ONCE_FORWARD,120,go.EASING_INOUTCUBIC,3.5,0,function()bee_flip(horizontal)end)
		else
			sprite.set_hflip("bee1#sprite", true)
			go.animate(horizontal,"position.x",go.PLAYBACK_ONCE_FORWARD,400,go.EASING_INOUTCUBIC,3.5,0,function()bee_flip(horizontal)end)
		end
	else
		local bee_position = go.get_position(vertical)
		if bee_position.y == 520 then
			sprite.set_vflip("bee2#sprite", true)
			go.animate(vertical,"position.y",go.PLAYBACK_ONCE_FORWARD,200,go.EASING_INOUTCUBIC,3.5,0.6,function()bee_flip(vertical)end)
		else
			sprite.set_vflip("bee2#sprite", false)
			go.animate(vertical,"position.y",go.PLAYBACK_ONCE_FORWARD,520,go.EASING_INOUTCUBIC,3.5,0.6,function()bee_flip(vertical)end)
		end
	end
end

function init(self) -- < 3 >
	bee_flip(horizontal)
	bee_flip(vertical)
end

--[[

1. 2 game object id's are set as local strings for horizontal and vertical examples.

2. bee_flip() function takes in the go's id then an if statement is used to determine go's
	position and sets horizontal or vertical flip to sprite accordingly. Then go.animate is
	used and a callback to bee_flip() occurs at the end of the animation.

3. In the initialize function we call bee_flip() for both horizontal and vertical bee 
	game objects.

--]]
```

<!-- sprite/samplers -->

# Multiple Sprite Samplers {#examples:sprite:samplers}

This example shows how to sample from more than one image when drawing a sprite

[Project files](https://github.com/defold/examples/tree/master/sprite/samplers)

The example uses a sprite with a material with two samplers:

The samplers are assigned to two atlases, `one.atlas` and `two.atlas`:

Each atlas contains a Defold logo:

Note the rename pattern in `two.atlas`. The rename pattern is required so that it is possible to sample from the same location in both atlases.

The color data from the two samplers is mixed/interpolated in the fragment program to produce a final color. The amount of interpolation is controlled in the `mix_amount` fragment constant. The `mix_amount` is animated between 0.0 and 1.0 in the `multi_sample.script`

## Scripts

### multi_sample.script

```lua
function init(self)
	go.animate("logo#sprite", "mix_amount.x", go.PLAYBACK_LOOP_PINGPONG, 1.0, go.EASING_INOUTQUAD, 2)
end
```

### multi_sample_sprite.fp

```glsl
varying mediump vec2 var_texcoord0;

uniform lowp sampler2D texture1_sampler;
uniform lowp sampler2D texture2_sampler;
uniform lowp vec4 tint;
uniform lowp vec4 mix_amount;

void main()
{
    // Pre-multiply alpha since all runtime textures already are
    lowp vec4 tint_pm = vec4(tint.xyz * tint.w, tint.w);
    // sample from both textures
    lowp vec4 color1 = texture2D(texture1_sampler, var_texcoord0.xy);
    lowp vec4 color2 = texture2D(texture2_sampler, var_texcoord0.xy);
    // mix (interpolate) the colors by the mix_amount
    lowp vec4 colormix = mix(color1, color2, mix_amount.x);
    // apply tint
    gl_FragColor = colormix * tint_pm;
}
```

<!-- sprite/cursor -->

# Sprite cursor {#examples:sprite:cursor}

This example shows how to use the sprite animation cursor and frame count to manually select a specific frame

[Project files](https://github.com/defold/examples/tree/master/sprite/cursor)

The example contains a sprite with a tilesource animation of a walking robot. The animation consists of 8 frames:

The example also contains a script and some visual controls that can be used to step through or automatically play the tilesource animation using the animation cursor:

## Scripts

### cursor.script

```lua
-- step animation forward or backwards 'amount' number of frames
local function step(self, amount)
	-- frame_count is the number of frames in the current animationm 
	local frame_count = go.get("#sprite", "frame_count")
	-- cursor is the normalized (0.0 to 1.0) animation cursor
	local cursor = go.get("#sprite", "cursor")

	-- normalized length of a frame in the current animation
	local frame_length = 1 / frame_count

	-- move the cursor amount number of frames
	cursor = cursor + (frame_length * amount)

	-- wrap animation if advancing beyond the first or last frame
	if cursor < 0 then
		cursor = cursor + 1
	elseif cursor >= 1 then
		cursor = cursor - 1
	end

	-- set new sprite cursor position
	go.set("#sprite", "cursor", cursor)

	-- calculate the current animation frame and show on a label
	local current_frame = 1 + math.floor(cursor * frame_count)
	label.set_text("#frame", ("%d / %d"):format(current_frame, frame_count))
end

-- stop automatic animation playback
local function stop(self)
	-- only try to stop if there is an active timer
	if self.playback_timer then
		-- visually update the start/stop sprite to show the 'start image
		sprite.play_flipbook("controls#playstop", "start")
		-- cancel the animation timer
		timer.cancel(self.playback_timer)
		self.playback_timer = nil
	end
end

-- start automatic animation playback using a timer to advance the animation
-- one frame at a time
local function start(self)
	-- visually update the start/stop sprite to show the 'stop' image
	sprite.play_flipbook("controls#playstop", "stop")
	-- start a timer to advance the animation roughly every 0.15 seconds
	self.playback_timer = timer.delay(0.15, true, function()
		step(self, 1)
	end)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.playback_timer = nil
end

function on_input(self, action_id, action)
	if action.pressed then
		-- key left or mouse click on left part of screen
		-- step animation one frame backwards
		if action_id == hash("key_left")
		or action_id == hash("mouse_button_left") and action.x < 240
		then
			stop(self)
			step(self, -1)
			return
		end
		
		-- key right or mouse click on right part of the screen
		-- step animation one frame forward	
		if action_id == hash("key_right")
		or action_id == hash("mouse_button_left") and action.x > 480 then
			stop(self)
			step(self, 1)
			return
		end

		-- key space or mouse click in central part of the screen
		-- start or stop animation playback
		if action_id == hash("key_space")
		or action_id == hash("mouse_button_left") and action.x > 240 and action.x < 480 then
			if self.playback_timer then
				stop(self)
			else
				start(self)
			end
		end
	end
end
```

<!-- sprite/size -->

# Sprite size {#examples:sprite:size}

This example shows how to get the size of a sprite at run-time

[Project files](https://github.com/defold/examples/tree/master/sprite/size)

The example uses two game objects, each with a sprite component and a label (to show the size). One of game objects contains the script that reads the size and shows it on the labels:

## Scripts

### size.script

```lua
function init(self)
	local rectangle_size = go.get("#stone", "size") -- <1>
	local square_size = go.get("square#stone", "size") -- <2>
	label.set_text("#info", "" .. rectangle_size.x .. "x" .. rectangle_size.y) -- <3>
	label.set_text("square#info", "" .. square_size.x .. "x" .. square_size.y) -- <4>
end

--[[
1. Read the size of the sprite with id `stone` on the same game object as this script (the game object with id `rectangle`).
2. Read the size of the sprite with id `stone` on the game object with id `square`.
3. Set the text of the label with id `info` on the same game object as this script (the game object with id `rectangle`).
4. Set the text of the label with id `info` on the game object with id `square`.
--]]
```

<!-- sprite/tint -->

# Sprite tint {#examples:sprite:tint}

This example shows how tint a sprite at run-time

[Project files](https://github.com/defold/examples/tree/master/sprite/tint)

The example uses a script to tint (color) sprites in a couple of different ways. The tint is a fragment constant on the sprite material and it is used in the sprite.fp fragment shader program to modify the color sampled from the texture.

It is important to keep in mind that each tinted sprite generates a new draw call since a modified tint value will break the built in draw call batching in Defold.

## Scripts

### tint.script

```lua
function init(self)
	go.set("logo1#sprite", "tint", vmath.vector4(1, 0, 0, 1)) -- <1>
	go.set("logo2#sprite", "tint.x", 0) -- <2>
	go.set("logo3#sprite", "tint.w", 0.3) -- <3>
	go.animate("logo4#sprite", "tint", go.PLAYBACK_LOOP_PINGPONG, vmath.vector4(0, 0.5, 0.8, 1), go.EASING_INOUTQUAD, 2) -- <4>
	go.animate("logo5#sprite", "tint.w", go.PLAYBACK_LOOP_PINGPONG, 0, go.EASING_INOUTQUAD, 3) -- <4>
end

--[[
1. x,y,z,w -> r,g,b,a. Keep red and alpha. Remove green and blue.
2. x = red. Remove the red color component completely
3. w = alpha. Make the sprite semi-transparent
4. The tint property can be animated, either as a whole or each individual value
--]]
```

<!-- tilemap/get_set_tile -->

# Get and set tiles {#examples:tilemap:get_set_tile}

This example shows how to get and set tiles of a tilemap

[Project files](https://github.com/defold/examples/tree/master/tilemap/get_set_tile)

This example uses a tilemap and a script file to read mouse input to place tiles or read information about the tile the mouse is hovering.

---

Tilemap graphics made by [Kenney](https://www.kenney.nl).

## Scripts

### get_set_tile.script

```lua
local TILE_SIZE = 64

-- helper function check if a tile coordinate is within the bounds of the tilemap
local function within_bounds(x, y)
	local bx, by, bw, bh = tilemap.get_bounds("#level")
	return x >= bx and y >= by and x < (bx + bw) and y < (by + bh)
end

function init(self)
	msg.post(".", "acquire_input_focus")
end

function on_input(self, action_id, action)
	local tile_x = math.ceil(action.x / TILE_SIZE)
	local tile_y = math.ceil(action.y / TILE_SIZE)

	if within_bounds(tile_x, tile_y) then
		-- click to place a flower
		if action_id == hash("touch") and action.pressed then
			tilemap.set_tile("#level", "layer1", tile_x, tile_y, 77)
		end

		-- show tile info
		local tile = tilemap.get_tile("#level", "layer1", tile_x, tile_y)
		local text = ("x: %d y: %d tile: %d"):format(tile_x, tile_y, tile)
		label.set_text("#label", text)
	else
		local text = ("x: %d y: %d out of bounds"):format(tile_x, tile_y)
		label.set_text("#label", text)
	end
end
```

<!-- tilemap/collisions -->

# Tilemap collisions {#examples:tilemap:collisions}

This example shows how to detect collisions on tilemaps

[Project files](https://github.com/defold/examples/tree/master/tilemap/collisions)

This example uses a tilesource with two collision groups: "ground" and "danger". The tilesource uses the `tilesheet_complete.png` image for the tiles and the collision shapes (traced as outlines around the transparent pixels of each tile).

The tiles belonging to the two groups have been "painted" as can be seen by the outline around each tile. The tiles belonging to the "danger" group are purple and the tiles belonging to the "ground" group are green. Tiles with a white outline does not belong to a collision group.

The tilemap component uses the tilesource:

The tilemap is added to the example together with a collision object which uses the tilemap itself as collision shape. Note that there is no need to specify any collsion groups on the collision object itself. The groups defined in the tilesource (ie "ground" and "danger") will be used:

Click/tap on the screen to spawn game objects that will fall and interact with the tilemap.

---

Tilemap and enemy graphics made by [Kenney](https://www.kenney.nl).

## Scripts

### collisions.script

```lua
function init(self)
	msg.post(".", "acquire_input_focus") -- <1>
	for i=1,10 do
		factory.create("#enemyfactory", vmath.vector3(math.random(100, 700), 600, 1))  -- <2>
	end
end


function on_input(self, action_id, action)
	if action_id == hash("mouse_button_left") and action.pressed then
		factory.create("#enemyfactory", vmath.vector3(action.x, action.y, 1))  -- <3>
	end
end


function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then  -- <4>
		if message.own_group == hash("danger") then  -- <5>
			go.delete(message.other_id)  -- <6>
		end
	end
end

--[[
1. Acquire input for the script
2. Spawn 10 game objects at random positions near the top of the screen
3. Spawn a game object when the left mouse button (or touch) is pressed
4. Something collided with the tilemap if the received message was a `collision_response`
5. Check if something collided with a tile belonging to the collision group "danger"
6. Delete the game object that collided with the tilemap
--]]
```

<!-- timer/cancel_timer -->

# Cancel timer example {#examples:timer:cancel_timer}

This example shows how to create timer and cancel it anytime, using built-in timer API.

[Project files](https://github.com/defold/examples/tree/master/timer/cancel_timer)

The example shows how to use Defold built-in timer and uses two indicators:

1. A particlefx gui node that is triggered every 1s.
2. A text node with an information displaying.

The particle fx is played every 1s showing small eruption.
You can click anywhere to cancel the timer and the particlefx won't be triggered anymore.

## Scripts

### cancel_timer.gui_script

```lua
function init(self)
	local interval = 1		-- <1>
	local repeating = true	-- <2>

	self.timer = timer.delay(interval, repeating, function()	-- <3>
		local node = gui.get_node("particlefx")					-- <4>
		gui.play_particlefx(node)								-- <5>
	end)

	msg.post(".", "acquire_input_focus")	-- <6>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then	-- <7>
		timer.cancel(self.timer)							-- <8>
		local node = gui.get_node("info")					-- <9>
		gui.set_text(node, "Timer cancelled.")				-- <10>
	end
end

--[[
1. We will use interval of 1 (s).
2. We will be repeating the timer endlessly.
3. Start the timer with interval (1s) and repeating (true) and pass a callback function.
	Store the handle to the timer in self.timer.
4. Get the particle fx node.
5. Play particle fx in each call of the callback function of the timer.
6. Tell the engine that this game object wants to receive input.
7. If the user clicks.
8. Cancel the timer using the saved self.timer handle.
9. Get the text node.
10. Update text node with an information that the timer was cancelled.
--]]
```

<!-- timer/repeating_timer -->

# Repeating timer example {#examples:timer:repeating_timer}

This example shows how to create timer that repeats endlessly every second

[Project files](https://github.com/defold/examples/tree/master/timer/repeating_timer)

The example shows how to use Defold built-in timer and uses two indicators:

1. A numerical time text with seconds counter created using a text node
2. A circular time indicator created using a pie node

The timer trigers updates of those two indicators every 1s to form a counter.

## Scripts

### repeating_timer.gui_script

```lua
-- set value of numeric time indicator (from 0 to 60s)
local function update_numeric(p)
	local node = gui.get_node("numeric")
	gui.set_text(node, tostring(p) .. "s")
end

-- update radial/circle time indicator by changing the fill angle
local function update_radial(p)
	local node = gui.get_node("radial")
	local angle = p * 6
	gui.set_fill_angle(node, angle)
end

function init(self)
	self.count = 0			-- <1>
	local interval = 1		-- <2>
	local repeating = true	-- <3>

	timer.delay(interval, repeating, function()		-- <4>
		self.count = self.count + 1					-- <5>
		local p = self.count % 60					-- <6>
		update_numeric(p)							-- <7>
		update_radial(p)							-- <8>
	end)
end

--[[
1. Start the count with value 0.
2. We will use interval of 1 [s].
3. We will be repeating the timer endlessly.
4. Start the timer with interval (1s) and repeating (true) and pass a callback function.
5. The function will be called every 1s, so increase the count by 1 each time.
6. Get the modulo of 60, because the timer will be reset every 60s.
7. Update the numeric display of seconds passed.
8. Update the radial indicator of seconds passed.
--]]
```

<!-- timer/trigger_timer -->

# Trigger timer example {#examples:timer:trigger_timer}

This example shows how to create timer that triggers counting every 1s and can be triggered manually and asynchronously as a reaction to user input.

[Project files](https://github.com/defold/examples/tree/master/timer/trigger_timer)

The example shows how to use Defold built-in timer and trigger it asynchronously and uses two indicators:

1. A counter text increased every 1s created using a text node.
2. A text node with information displayed.

The timer triggers update of the counter every 1s.
Click anywhere to trigger the callback of the timer asynchronously.

## Scripts

### trigger_timer.gui_script

```lua
function init(self)
	self.count = 0			-- <1>
	local interval = 1		-- <2>
	local repeating = true	-- <3>

	self.timer = timer.delay(interval, repeating, function()	-- <4>
		self.count = self.count + 1								-- <5>
		local node = gui.get_node("counter")					-- <6>
		gui.set_text(node, self.count)							-- <7>
	end)

	msg.post(".", "acquire_input_focus")	-- <8>
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then	-- <9>
		timer.trigger(self.timer)							-- <10>
	end
end

--[[
1. Start the count with value 0.
2. We will use interval of 1 [s].
3. We will be repeating the timer endlessly.
4. Start the timer with interval (1s) and repeating (true) and pass a callback function.
	Store the handle to the timer in self.timer.
5. The function will be called every 1s, so increase the count by 1 each time.
6. Get the counter text node.
7. Update the counter text node with an increased count.
8. Tell the engine that this game object wants to receive input.
9. If the user clicks.
10. Trigger the timer's callback function asynchronously using the saved self.timer handle.
--]]
```
